package fmtappendf

import (
	"fmt"
)

func two() string {
	return "two"
}

func bye() {
	_ = fmt.Appendf(nil, "bye %d", 1) // want "Replace .*Sprintf.* with fmt.Appendf"
}

func funcsandvars() {
	one := "one"
	_ = fmt.Appendf(nil, "bye %d %s %s", 1, two(), one) // want "Replace .*Sprintf.* with fmt.Appendf"
}

func typealias() {
	type b = byte
	type bt = []byte
	_ = fmt.Appendf(nil, "bye %d", 1) // want "Replace .*Sprintf.* with fmt.Appendf"
	_ = fmt.Appendf(nil, "bye %d", 1) // want "Replace .*Sprintf.* with fmt.Appendf"
}

func otherprints() {
	_ = fmt.Append(nil, "bye %d", 1) // want "Replace .*Sprint.* with fmt.Append"
	_ = fmt.Appendln(nil, "bye %d", 1) // want "Replace .*Sprintln.* with fmt.Appendln"
}

func comma() {
	type S struct{ Bytes []byte }
	var _ = struct{ A S }{
		A: S{
			Bytes: fmt.Appendf(nil, "%d", 0),
		},
	}
	_ = fmt.Appendf(nil, "%d", 0)          
}

func emptystring() {
	// empty string edge case only applies to Sprintf
	_ = fmt.Appendln(nil, "")  // want "Replace .*Sprintln.* with fmt.Appendln"
	// nope - these return []byte{}, while the fmt.Append version returns nil
	_ = []byte(fmt.Sprint(""))
	_ = []byte(fmt.Sprintf("%s", ""))
	_ = []byte(fmt.Sprintf("%#s", ""))
	_ = []byte(fmt.Sprintf("%s%v", "", getString()))
	// conservatively omitting a suggested fix (ignoring precision and args)
	_ = []byte(fmt.Sprintf("%.0q", "notprinted"))
	_ = []byte(fmt.Sprintf("%v", "nonempty"))
	// has non-operation characters
	_ = fmt.Appendf(nil, "%vother", "") // want "Replace .*Sprint.* with fmt.Appendf"
}

func multiline() []byte {
	_ = fmt.Appendf(nil, "str %d", 1)

	return fmt.Appendf(nil, "str %d", 1)
}

func getString() string {
	return ""
}