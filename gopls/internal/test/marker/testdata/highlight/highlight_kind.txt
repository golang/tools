This test checks textDocument/highlight with highlight kinds.

-- highlight_kind.go --
package a

type Nest struct {
	nest *Nest //@hiloc(fNest, "nest", "Read")
}
type MyMap map[string]string

type NestMap map[Nest]Nest

func highlightTest() {
	const constIdent = 1 //@hiloc(constIdent, "constIdent", "Write"), highlighteach(constIdent)
	var varNoInit int    //@hiloc(varNoInit, "varNoInit", "Write")
	(varNoInit) = 1      //@hiloc(varNoInitAssign, "varNoInit", "Write")
	_ = varNoInit        //@hiloc(varNoInitRead, "varNoInit", "Read")
	//@highlighteach(varNoInit, varNoInitAssign, varNoInitRead)

	str, num := "hello", 2 //@hiloc(str, "str", "Write"), hiloc(num, "num", "Write")
	_, _ = str, num        //@hiloc(strRead, "str", "Read"), hiloc(numRead, "num", "Read")
	//@highlighteach(str, strRead, strMapKey, strMapVal, strMyMapKey, strMyMapVal, strMyMapSliceKey, strMyMapSliceVal, strMyMapPtrSliceKey, strMyMapPtrSliceVal)
	//@highlighteach(num, numRead, numAddr, numIncr, numMul)
	nest := &Nest{nest: nil} //@hiloc(nest, "nest", "Write"),hiloc(fNestComp, re`(nest):`, "Write")
	nest.nest = &Nest{}      //@hiloc(nestSelX, "nest", "Read"), hiloc(fNestSel, re`(nest) =`, "Write")
	*nest.nest = Nest{}      //@hiloc(nestSelXStar, "nest", "Read"), hiloc(fNestSelStar, re`(nest) =`, "Write")
	//@highlighteach(nest, nestSelX, nestSelXStar, nestMapVal)
	//@highlighteach(fNest, fNestComp, fNestSel, fNestSelStar, fNestSliceComp, fNestPtrSliceComp, fNestMapKey)

	pInt := &num //@hiloc(pInt, "pInt", "Write"),hiloc(numAddr, "num", "Read")
	// StarExpr is treated as write in GoLand and Rust Analyzer
	*pInt = 3               //@hiloc(pIntStar, "pInt", "Write")
	var ppInt **int = &pInt //@hiloc(ppInt, "ppInt", "Write"),hiloc(pIntAddr, re`&(pInt)`, "Read")
	**ppInt = 4             //@hiloc(ppIntStar, "ppInt", "Write")
	*(*ppInt) = 4           //@hiloc(ppIntParen, "ppInt", "Write")
	//@highlighteach(pInt, pIntStar, pIntAddr)
	//@highlighteach(ppInt, ppIntStar, ppIntParen)

	num++    //@hiloc(numIncr, "num", "Write")
	num *= 1 //@hiloc(numMul, "num", "Write")

	var ch chan int = make(chan int, 10) //@hiloc(ch, "ch", "Write")
	ch <- 3                              //@hiloc(chSend, "ch", "Write")
	<-ch                                 //@hiloc(chRecv, "ch", "Read")
	//@highlighteach(ch, chSend, chRecv)

	var nums []int = []int{1, 2} //@hiloc(nums, "nums", "Write")
	// IndexExpr is treated as read in GoLand, Rust Analyzer and Java JDT
	nums[0] = 1 //@hiloc(numsIndex, "nums", "Read")
	//@highlighteach(nums, numsIndex)

	mapLiteral := map[string]string{ //@hiloc(mapLiteral, "mapLiteral", "Write")
		str: str, //@hiloc(strMapKey, "str", "Read"),hiloc(strMapVal, re`(str),`, "Read")
	}
	for key, value := range mapLiteral { //@hiloc(mapKey, "key", "Write"), hiloc(mapVal, "value", "Write"), hiloc(mapLiteralRange, "mapLiteral", "Read")
		_, _ = key, value //@hiloc(mapKeyRead, "key", "Read"), hiloc(mapValRead, "value", "Read")
	}
	//@highlighteach(mapLiteral, mapLiteralRange)
	//@highlighteach(mapKey, mapKeyRead)
	//@highlighteach(mapVal, mapValRead)

	nestSlice := []Nest{
		{nest: nil}, //@hiloc(fNestSliceComp, "nest", "Write")
	}
	nestPtrSlice := []*Nest{
		{nest: nil}, //@hiloc(fNestPtrSliceComp, "nest", "Write")
	}
	myMap := MyMap{
		str: str, //@hiloc(strMyMapKey, "str", "Read"),hiloc(strMyMapVal, re`(str),`, "Read")
	}
	myMapSlice := []MyMap{
		{str: str}, //@hiloc(strMyMapSliceKey, "str", "Read"),hiloc(strMyMapSliceVal, re`: (str)`, "Read")
	}
	myMapPtrSlice := []*MyMap{
		{str: str}, //@hiloc(strMyMapPtrSliceKey, "str", "Read"),hiloc(strMyMapPtrSliceVal, re`: (str)`, "Read")
	}
	nestMap := NestMap{
		Nest{nest: nil}: *nest, //@hiloc(fNestMapKey, "nest", "Write"), hiloc(nestMapVal, re`(nest),`, "Read")
	}

	_, _, _, _, _, _ = myMap, nestSlice, nestPtrSlice, myMapSlice, myMapPtrSlice, nestMap
}
