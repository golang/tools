This test checks basic functionality of the textDocument/highlight request.

-- highlights.go --
package highlights

import (
	"fmt"         //@hiloc(fmtImp, "\"fmt\"", "Text"),highlight(fmtImp, fmtImp, fmt1, fmt2, fmt3, fmt4)
	h2 "net/http" //@hiloc(hImp, "h2", "Text"),highlight(hImp, hImp, hUse)
	"sort"
)

type F struct{ bar int } //@hiloc(barDeclaration, "bar", "Text"),highlight(barDeclaration, barDeclaration, bar1, bar2, bar3)

func _() F {
	return F{
		bar: 123, //@hiloc(bar1, "bar", "Write"),highlight(bar1, barDeclaration, bar1, bar2, bar3)
	}
}

var foo = F{bar: 52} //@hiloc(fooDeclaration, "foo", "Write"),hiloc(bar2, "bar", "Write"),highlight(fooDeclaration, fooDeclaration, fooUse),highlight(bar2, barDeclaration, bar1, bar2, bar3)

func Print() { //@hiloc(printFunc, "Print", "Text"),highlight(printFunc, printFunc, printTest)
	_ = h2.Client{} //@hiloc(hUse, "h2", "Text"),highlight(hUse, hImp, hUse)

	fmt.Println(foo) //@hiloc(fooUse, "foo", "Read"),highlight(fooUse, fooDeclaration, fooUse),hiloc(fmt1, "fmt", "Text"),highlight(fmt1, fmtImp, fmt1, fmt2, fmt3, fmt4)
	fmt.Print("yo")  //@hiloc(printSep, "Print", "Text"),highlight(printSep, printSep, print1, print2),hiloc(fmt2, "fmt", "Text"),highlight(fmt2, fmtImp, fmt1, fmt2, fmt3, fmt4)
}

func (x *F) Inc() { //@hiloc(xRightDecl, "x", "Text"),hiloc(xLeftDecl, " *", "Text"),highlight(xRightDecl, xRightDecl, xUse),highlight(xLeftDecl, xRightDecl, xUse)
	x.bar++ //@hiloc(xUse, "x", "Read"),hiloc(bar3, "bar", "Write"),highlight(xUse, xRightDecl, xUse),highlight(bar3, barDeclaration, bar1, bar2, bar3)
}

func testFunctions() {
	fmt.Print("main start") //@hiloc(print1, "Print", "Text"),highlight(print1, printSep, print1, print2),hiloc(fmt3, "fmt", "Text"),highlight(fmt3, fmtImp, fmt1, fmt2, fmt3, fmt4)
	fmt.Print("ok")         //@hiloc(print2, "Print", "Text"),highlight(print2, printSep, print1, print2),hiloc(fmt4, "fmt", "Text"),highlight(fmt4, fmtImp, fmt1, fmt2, fmt3, fmt4)
	Print()                 //@hiloc(printTest, "Print", "Text"),highlight(printTest, printFunc, printTest)
}

// DocumentHighlight is undefined, so its uses below are type errors.
// Nevertheless, document highlighting should still work.
//@diag(locdoc1, re"undefined|undeclared"), diag(locdoc2, re"undefined|undeclared"), diag(locdoc3, re"undefined|undeclared")

func toProtocolHighlight(rngs []int) []DocumentHighlight { //@loc(locdoc1, "DocumentHighlight"), hiloc(doc1, "DocumentHighlight", "Text"),hiloc(docRet1, "[]DocumentHighlight", "Text"),highlight(doc1, docRet1, doc1, doc2, doc3, result)
	result := make([]DocumentHighlight, 0, len(rngs)) //@loc(locdoc2, "DocumentHighlight"), hiloc(doc2, "DocumentHighlight", "Text"),highlight(doc2, doc1, doc2, doc3)
	for _, rng := range rngs {
		result = append(result, DocumentHighlight{ //@loc(locdoc3, "DocumentHighlight"), hiloc(doc3, "DocumentHighlight", "Text"),highlight(doc3, doc1, doc2, doc3)
			Range: rng,
		})
	}
	return result //@hiloc(result, "result", "Text")
}

func testForLoops() {
	for i := 0; i < 10; i++ { //@hiloc(forDecl1, "for", "Text"),highlight(forDecl1, forDecl1, brk1, cont1)
		if i > 8 {
			break //@hiloc(brk1, "break", "Text"),highlight(brk1, forDecl1, brk1, cont1)
		}
		if i < 2 {
			for j := 1; j < 10; j++ { //@hiloc(forDecl2, "for", "Text"),highlight(forDecl2, forDecl2, cont2)
				if j < 3 {
					for k := 1; k < 10; k++ { //@hiloc(forDecl3, "for", "Text"),highlight(forDecl3, forDecl3, cont3)
						if k < 3 {
							continue //@hiloc(cont3, "continue", "Text"),highlight(cont3, forDecl3, cont3)
						}
					}
					continue //@hiloc(cont2, "continue", "Text"),highlight(cont2, forDecl2, cont2)
				}
			}
			continue //@hiloc(cont1, "continue", "Text"),highlight(cont1, forDecl1, brk1, cont1)
		}
	}

	arr := []int{}
	for i := range arr { //@hiloc(forDecl4, "for", "Text"),highlight(forDecl4, forDecl4, brk4, cont4)
		if i > 8 {
			break //@hiloc(brk4, "break", "Text"),highlight(brk4, forDecl4, brk4, cont4)
		}
		if i < 4 {
			continue //@hiloc(cont4, "continue", "Text"),highlight(cont4, forDecl4, brk4, cont4)
		}
	}

Outer:
	for i := 0; i < 10; i++ { //@hiloc(forDecl5, "for", "Text"),highlight(forDecl5, forDecl5, brk5, brk6, brk8)
		break //@hiloc(brk5, "break", "Text"),highlight(brk5, forDecl5, brk5, brk6, brk8)
		for { //@hiloc(forDecl6, "for", "Text"),highlight(forDecl6, forDecl6, cont5), diag("for", re"unreachable")
			if i == 1 {
				break Outer //@hiloc(brk6, "break Outer", "Text"),highlight(brk6, forDecl5, brk5, brk6, brk8)
			}
			switch i { //@hiloc(switch1, "switch", "Text"),highlight(switch1, switch1, brk7)
			case 5:
				break //@hiloc(brk7, "break", "Text"),highlight(brk7, switch1, brk7)
			case 6:
				continue //@hiloc(cont5, "continue", "Text"),highlight(cont5, forDecl6, cont5)
			case 7:
				break Outer //@hiloc(brk8, "break Outer", "Text"),highlight(brk8, forDecl5, brk5, brk6, brk8)
			}
		}
	}
}

func testSwitch() {
	var i, j int

L1:
	for { //@hiloc(forDecl7, "for", "Text"),highlight(forDecl7, forDecl7, brk10, cont6)
	L2:
		switch i { //@hiloc(switch2, "switch", "Text"),highlight(switch2, switch2, brk11, brk12, brk13)
		case 1:
			switch j { //@hiloc(switch3, "switch", "Text"),highlight(switch3, switch3, brk9)
			case 1:
				break //@hiloc(brk9, "break", "Text"),highlight(brk9, switch3, brk9)
			case 2:
				break L1 //@hiloc(brk10, "break L1", "Text"),highlight(brk10, forDecl7, brk10, cont6)
			case 3:
				break L2 //@hiloc(brk11, "break L2", "Text"),highlight(brk11, switch2, brk11, brk12, brk13)
			default:
				continue //@hiloc(cont6, "continue", "Text"),highlight(cont6, forDecl7, brk10, cont6)
			}
		case 2:
			break //@hiloc(brk12, "break", "Text"),highlight(brk12, switch2, brk11, brk12, brk13)
		default:
			break L2 //@hiloc(brk13, "break L2", "Text"),highlight(brk13, switch2, brk11, brk12, brk13)
		}
	}
}

func testReturn() bool { //@hiloc(func1, "func", "Text"),hiloc(bool1, "bool", "Text"),highlight(func1, func1, fullRet11, fullRet12)
//@highlight(bool1, bool1, false1, bool2, true1)
	if 1 < 2 {
		return false //@hiloc(ret11, "return", "Text"),hiloc(fullRet11, "return false", "Text"),hiloc(false1, "false", "Text"),highlight(ret11, func1, fullRet11, fullRet12)
	}
	candidates := []int{}
	sort.SliceStable(candidates, func(i, j int) bool { //@hiloc(func2, "func", "Text"),hiloc(bool2, "bool", "Text"),highlight(func2, func2, fullRet2)
		return candidates[i] > candidates[j] //@hiloc(ret2, "return", "Text"),hiloc(fullRet2, "return candidates[i] > candidates[j]", "Text"),highlight(ret2, func2, fullRet2)
	})
	return true //@hiloc(ret12, "return", "Text"),hiloc(fullRet12, "return true", "Text"),hiloc(true1, "true", "Text"),highlight(ret12, func1, fullRet11, fullRet12)
}

func testReturnFields() float64 { //@hiloc(retVal1, "float64", "Text"),highlight(retVal1, retVal1, retVal11, retVal21)
	if 1 < 2 {
		return 20.1 //@hiloc(retVal11, "20.1", "Text"),highlight(retVal11, retVal1, retVal11, retVal21)
	}
	z := 4.3 //@hiloc(zDecl, "z", "Write")
	return z //@hiloc(retVal21, "z", "Text"),highlight(retVal21, retVal1, retVal11, zDecl, retVal21)
}

func testReturnMultipleFields() (float32, string) { //@hiloc(retVal31, "float32", "Text"),hiloc(retVal32, "string", "Text"),highlight(retVal31, retVal31, retVal41, retVal51),highlight(retVal32, retVal32, retVal42, retVal52)
	y := "im a var" //@hiloc(yDecl, "y", "Write"),
	if 1 < 2 {
		return 20.1, y //@hiloc(retVal41, "20.1", "Text"),hiloc(retVal42, "y", "Text"),highlight(retVal41, retVal31, retVal41, retVal51),highlight(retVal42, retVal32, yDecl, retVal42, retVal52)
	}
	return 4.9, "test" //@hiloc(retVal51, "4.9", "Text"),hiloc(retVal52, "\"test\"", "Text"),highlight(retVal51, retVal31, retVal41, retVal51),highlight(retVal52, retVal32, retVal42, retVal52)
}

func testReturnFunc() int32 { //@hiloc(retCall, "int32", "Text")
	mulch := 1          //@hiloc(mulchDec, "mulch", "Write"),highlight(mulchDec, mulchDec, mulchRet)
	return int32(mulch) //@hiloc(mulchRet, "mulch", "Read"),hiloc(retFunc, "int32", "Text"),hiloc(retTotal, "int32(mulch)", "Text"),highlight(mulchRet, mulchDec, mulchRet),highlight(retFunc, retCall, retFunc, retTotal)
}
