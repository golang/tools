This test checks the return type of the generated missing method based on CallExpr.

-- basic_stub.go --
package fromcallreturns

-- param.go --
package fromcallreturns

type A struct{}

func inferFromParam() {
	a := A{}
	f(a.as_param()) //@quickfix("as_param", re"has no field or method", infer_param)
}

func f(i int) {}
-- @infer_param/param.go --
@@ -5 +5,4 @@
+func (a A) as_param() int {
+	panic("unimplemented")
+}
+
-- assign.go --
package fromcallreturns

type Assign struct{}

func inferReturnfromAssign() {
	var assign int //@diag("assign",re"not used")
	a := Assign{}
	assign = a.as_assign() //@quickfix("as_assign", re"has no field or method", infer_assign)
}
-- @infer_assign/assign.go --
@@ -5 +5,4 @@
+func (a Assign) as_assign() int {
+	panic("unimplemented")
+}
+
-- multiple_assign.go --
package fromcallreturns

type MultiAssign struct{}

func inferReturnfromMultipleAssign() {
	var assign1 int //@diag("assign1",re"not used")
	var assign2 int //@diag("assign2",re"not used")
	m := MultiAssign{}
	assign1, assign2 = m.multi_assign() //@quickfix("multi_assign", re"has no field or method", infer_multiple_assign)
}
-- @infer_multiple_assign/multiple_assign.go --
@@ -5 +5,4 @@
+func (m MultiAssign) multi_assign() (int, int) {
+	panic("unimplemented")
+}
+
-- multiple_return_in_param.go --
package fromcallreturns

type MultiReturn struct{}

func inferMultipleReturnInParam() {
	m := MultiReturn{}
	m.param_has_multi_return(multiReturn()) //@quickfix("param_has_multi_return", re"has no field or method", multiple_return)
}

func multiReturn() (int, int) {
	return 1, 1
}
-- @multiple_return/multiple_return_in_param.go --
@@ -5 +5,4 @@
+func (m MultiReturn) param_has_multi_return(i int, param2 int) {
+	panic("unimplemented")
+}
+
-- error_nodes.go --
package fromcallreturns

type E struct{}

func all_error() {
	e := E{}
	errorFunc(e.errors(undefined1(), undefined2(), undefined3{})) //@quickfix("errors", re"has no field or method", all_error),diag("undefined1",re"undefined"),diag("undefined2",re"undefined"),diag("undefined3",re"undefined")
}
func errorFunc(u undefined4) {} //@diag("undefined4",re"undefined")
-- @all_error/error_nodes.go --
@@ -5 +5,4 @@
+func (e E) errors(param any, param2 any, param3 any) any {
+	panic("unimplemented")
+}
+
-- paren.go --
package fromcallreturns

type Paren struct{}

func paren() {
	p := Paren{}
	fn()((p.surroundingParen())) //@quickfix("surroundingParen", re"has no field or method", surrounding_paren)
}

func fn() func(i int) {
	return func(i int) {}
}
-- @surrounding_paren/paren.go --
@@ -5 +5,4 @@
+func (p Paren) surroundingParen() int {
+	panic("unimplemented")
+}
+
