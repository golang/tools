-- basic_stub.go --
package stubcalled

type A struct{}

func basic() {
	a := A{}
	a.basic("s", 42, 4.12, make(map[string]int), []int{1}, [1]int{1}, make(chan string)) //@suggestedfix("basic", re"has no field or method", basic)
}
-- @basic/basic_stub.go --
@@ -5 +5,4 @@
+func (a A) basic(s string, i int, f float64, m map[string]int, i1 []int, i2 [1]int, ch chan string) {
+	panic("unimplemented")
+}
+
-- nonexistent_type.go --
package stubcalled

type B struct{}

func invalidBasicKind() {
	b := B{}
	b.basicKind(NonExistentType{}) //@suggestedfix("basicKind", re"has no field or method", nonexistent),diag(re"NonExistentType",re"undefined: NonExistentType")
}
-- @nonexistent/nonexistent_type.go --
@@ -5 +5,4 @@
+func (b B) basicKind(a any) {
+	panic("unimplemented")
+}
+
-- pass_param_by_ident.go --
package stubcalled

type C struct{}

func passParamByIdent() {
	c := C{}
	stringVar := "some string"
	intVar := 1
	sliceVar := []int{1}
	c.ident(stringVar, intVar, sliceVar) //@suggestedfix("ident", re"has no field or method", ident)
}
-- @ident/pass_param_by_ident.go --
@@ -5 +5,4 @@
+func (c C) ident(stringVar string, intVar int, sliceVar []int) {
+	panic("unimplemented")
+}
+
-- infer_return_from_param.go --
package stubcalled

type D struct{}

func inferReturnRromParam() {
	d := D{}
	f(d.as_param()) //@suggestedfix("as_param", re"has no field or method", infer_param)
}

func f(i int) {}
-- @infer_param/infer_return_from_param.go --
@@ -5 +5,4 @@
+func (d D) as_param() int {
+	panic("unimplemented")
+}
+
-- infer_return_from_assign.go --
package stubcalled

type E struct{}

func inferReturnfromAssign() {
	var assign int //@diag("assign", re"not used")
	e := E{}
	assign = e.as_assign() //@suggestedfix("as_assign", re"has no field or method", infer_assign)
}
-- @infer_assign/infer_return_from_assign.go --
@@ -5 +5,4 @@
+func (e E) as_assign() int {
+	panic("unimplemented")
+}
+
-- infer_return_from_multiple_assign.go --
package stubcalled

type F struct{}

func inferReturnfromMultipleAssign() {
	var assign1 int //@diag("assign", re"not used")
	var assign2 int //@diag("assign", re"not used")
	f := F{}
	assign1, assign2 = f.multi_assign() //@suggestedfix("multi_assign", re"has no field or method", infer_multiple_assign)
}
-- @infer_multiple_assign/infer_return_from_multiple_assign.go --
@@ -5 +5,4 @@
+func (f F) multi_assign() (int, int) {
+	panic("unimplemented")
+}
+
-- infer_multiple_return_in_param.go --
package stubcalled

type G struct{}

func inferMultipleReturnInParam() {
	g := G{}
	g.param_has_multi_return(multiReturn()) //@suggestedfix("param_has_multi_return", re"has no field or method", multiple_return)
}

func multiReturn() (int, int) {
	return 1, 1
}
-- @multiple_return/infer_multiple_return_in_param.go --
@@ -5 +5,4 @@
+func (g G) param_has_multi_return(i int, i1 int) {
+	panic("unimplemented")
+}
+
-- tail_param_name.go --
package stubcalled

type H struct{}

type TypeWithLongName struct{}

func TailParamName() {
	h := H{}
	h.longName(TypeWithLongName{}) //@suggestedfix("longName", re"has no field or method", trail)
}
-- @trail/tail_param_name.go --
@@ -5 +5,4 @@
+func (h H) longName(name TypeWithLongName) {
+	panic("unimplemented")
+}
+
-- param_and_return_all_error_nodes.go --
package stubcalled

type I struct{}

func all_error() {
	i := I{}
	errorFunc(i.errors(undefined1(), undefined2(), undefined3{})) //@suggestedfix("errors", re"has no field or method", all_error),diag("undefined1",re"undefined"),diag("undefined2",re"undefined"),diag("undefined3",re"undefined")
}
func errorFunc(u undefined4) {} //@diag("undefined4",re"undefined")
-- @all_error/param_and_return_all_error_nodes.go --
@@ -5 +5,4 @@
+func (i I) errors(a any, a1 any, a2 any) any {
+	panic("unimplemented")
+}
+
-- pointer.go --
package stubcalled

type J struct{}

func recv_param_pointer() {
	j := &J{}
	i := 42
	j.pointer(&i) //@suggestedfix("pointer", re"has no field or method", pointer)
}
-- @pointer/pointer.go --
@@ -5 +5,4 @@
+func (j *J) pointer(i *int) {
+	panic("unimplemented")
+}
+
