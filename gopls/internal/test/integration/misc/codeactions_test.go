// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package misc

import (
	"fmt"
	"slices"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"golang.org/x/tools/gopls/internal/protocol"
	"golang.org/x/tools/gopls/internal/protocol/command"
	"golang.org/x/tools/gopls/internal/settings"
	. "golang.org/x/tools/gopls/internal/test/integration"
)

// This test exercises the filtering of code actions in generated files.
// Most code actions, being potential edits, are discarded, but
// some (GoTest, GoDoc) are pure queries, and so are allowed.
func TestCodeActionsInGeneratedFiles(t *testing.T) {
	const src = `
-- go.mod --
module example.com
go 1.19

-- src/a.go --
package a

func f() { g() }
func g() {}
-- gen/a.go --
// Code generated by hand; DO NOT EDIT.
package a

func f() { g() }
func g() {}

-- issue72742/a.go --
package main

func main(){
	fmt.Println("helloworld")
}
`

	Run(t, src, func(t *testing.T, env *Env) {
		check := func(filename string, re string, want []protocol.CodeActionKind) {
			env.OpenFile(filename)
			loc := env.RegexpSearch(filename, re)
			actions, err := env.Editor.CodeAction(env.Ctx, loc, nil, protocol.CodeActionUnknownTrigger)
			if err != nil {
				t.Fatal(err)
			}

			type kinds = []protocol.CodeActionKind
			got := make(kinds, 0)
			for _, act := range actions {
				got = append(got, act.Kind)
			}

			if diff := cmp.Diff(want, got); diff != "" {
				t.Errorf("%s: unexpected CodeActionKinds: (-want +got):\n%s",
					filename, diff)
				t.Log(actions)
			}
		}

		check("src/a.go", `g\(\)`, []protocol.CodeActionKind{
			settings.AddTest,
			settings.GoAssembly,
			settings.GoDoc,
			settings.GoFreeSymbols,
			settings.GoSplitPackage,
			settings.GoToggleCompilerOptDetails,
			settings.RefactorInlineCall,
			settings.GoplsDocFeatures,
		})

		check("gen/a.go", `g\(\)`, []protocol.CodeActionKind{
			settings.GoAssembly,
			settings.GoDoc,
			settings.GoFreeSymbols,
			settings.GoSplitPackage,
			settings.GoToggleCompilerOptDetails,
			settings.GoplsDocFeatures,
		})

		check("issue72742/a.go", `fmt`, []protocol.CodeActionKind{
			settings.OrganizeImports,
			settings.AddTest,
			settings.GoAssembly,
			settings.GoDoc,
			settings.GoFreeSymbols,
			settings.GoSplitPackage,
			settings.GoToggleCompilerOptDetails,
			settings.GoplsDocFeatures,
		})
	})
}

// Test refactor.inline.call is not included in automatically triggered code action
// unless users want refactoring.
//
// (The mechanism behind this behavior has changed. It was added when
// we used to interpret CodeAction(Only=[]) as "all kinds", which was
// a distracting nuisance (too many lightbulbs); this was fixed by
// adding special logic to refactor.inline.call to respect the trigger
// kind; but now we do this for all actions (for similar reasons) and
// interpret Only=[] as Only=[quickfix] unless triggerKind=invoked;
// except that the test client always requests CodeAction(Only=[""]).
// So, we should remove the special logic from refactorInlineCall
// and vary the Only parameter used by the test client.)
func TestVSCodeIssue65167(t *testing.T) {
	const vim1 = `package main

func main() {
	Func()  // range to be selected
}

func Func() int { return 0 }
`

	Run(t, "", func(t *testing.T, env *Env) {
		env.CreateBuffer("main.go", vim1)
		for _, trigger := range []protocol.CodeActionTriggerKind{
			protocol.CodeActionUnknownTrigger,
			protocol.CodeActionInvoked,
			protocol.CodeActionAutomatic,
		} {
			t.Run(fmt.Sprintf("trigger=%v", trigger), func(t *testing.T) {
				for _, selectedRange := range []bool{false, true} {
					t.Run(fmt.Sprintf("range=%t", selectedRange), func(t *testing.T) {
						loc := env.RegexpSearch("main.go", "Func")
						if !selectedRange {
							// assume the cursor is placed at the beginning of `Func`, so end==start.
							loc.Range.End = loc.Range.Start
						}
						actions := env.CodeAction(loc, nil, trigger)
						want := trigger != protocol.CodeActionAutomatic || selectedRange
						if got := slices.ContainsFunc(actions, func(act protocol.CodeAction) bool {
							return act.Kind == settings.RefactorInlineCall
						}); got != want {
							t.Errorf("got refactor.inline.call = %t, want %t", got, want)
						}
					})
				}
			})
		}
	})
}

// TestDescendingRange isn't really a test of CodeAction at all: it
// merely tests the response of the server to any (start, end) range
// that is descending. See #74394.
func TestDescendingRange(t *testing.T) {
	const src = `
-- go.mod --
module example.com
go 1.19

-- a/a.go --
package a
`
	Run(t, src, func(t *testing.T, env *Env) {
		env.OpenFile("a/a.go")
		loc := env.RegexpSearch("a/a.go", "package")
		rng := &loc.Range
		rng.Start, rng.End = rng.End, rng.Start
		_, err := env.Editor.CodeAction(env.Ctx, loc, nil, protocol.CodeActionUnknownTrigger)
		got, wantSubstr := fmt.Sprint(err), "start (offset 7) > end (offset 0)"
		if !strings.Contains(got, wantSubstr) {
			t.Fatalf("CodeAction error: got %q, want substring %q", got, wantSubstr)
		}
	})
}

func TestGoToTestCodeAction(t *testing.T) {
	const src = `
-- a.go --
package codelenses

func bar() {
	_ = "bar"
}

func noTests() {
	_ = "no_tests"
}

-- a_test.go --
package codelenses_test

import "testing"

func Test_bar(*testing.T) {}

func Benchmark_bar(*testing.B) {}

func Fuzz_bar(*testing.F) {}

-- slices.go --
package codelenses

func Delete() {
	_ = "delete"
}

func DeleteFunc() {}

-- slices_test.go --
package codelenses

import "testing"

func TestDelete(*testing.T) {}

func TestDeleteClearTail(*testing.T) {}

func TestDeletePanics(*testing.T) {}

func TestDeleteFunc(*testing.T) {}

func TestDeleteFuncClearTail(*testing.T) {}

`

	Run(t, src, func(t *testing.T, env *Env) {
		getLoc := func(file, re string) protocol.Location {
			t.Helper()

			env.OpenFile(file)
			return env.RegexpSearch(file, re)
		}

		type CodeAction struct {
			Title string
			Loc   protocol.Location
		}
		for _, tt := range []struct {
			file, re string
			want     []CodeAction
		}{
			{
				file: "a.go", re: `_ = "bar"`,
				want: []CodeAction{
					{Title: "Go to Test_bar", Loc: getLoc("a_test.go", "()func Test_bar")},
					{Title: "Go to Benchmark_bar", Loc: getLoc("a_test.go", "()func Benchmark_bar")},
					{Title: "Go to Fuzz_bar", Loc: getLoc("a_test.go", "()func Fuzz_bar")},
				},
			},
			{
				file: "a.go", re: `_ = "no_tests"`,
				want: nil,
			},
			{
				file: "slices.go", re: `_ = "delete"`,
				want: []CodeAction{
					{Title: "Go to TestDelete", Loc: getLoc("slices_test.go", "()func TestDelete")},
					{Title: "Go to TestDeleteClearTail", Loc: getLoc("slices_test.go", "()func TestDeleteClearTail")},
					{Title: "Go to TestDeletePanics", Loc: getLoc("slices_test.go", "()func TestDeletePanics")},
				},
			},
		} {
			env.OpenFile(tt.file)
			loc := env.RegexpSearch(tt.file, tt.re)
			actions, err := env.Editor.CodeAction(env.Ctx, loc, nil, protocol.CodeActionUnknownTrigger)
			if err != nil {
				t.Fatal(err)
			}
			var got []CodeAction
			for _, v := range actions {
				if v.Kind == "source.go_to_test" {
					var loc protocol.Location
					err := command.UnmarshalArgs(v.Command.Arguments, &loc)
					if err != nil {
						t.Fatal(err)
					}
					got = append(got, CodeAction{
						Title: v.Title,
						Loc:   loc,
					})
				}
			}
			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Errorf("CodeAction mismatch (-want +got):\n%s", diff)
			}
		}
	})
}
