{
	"Options": {
		"User": [
			{
				"Name": "buildFlags",
				"Type": "[]string",
				"Doc": "buildFlags is the set of flags passed on to the build system when invoked.\nIt is applied to queries like `go list`, which is used when discovering files.\nThe most common use is to set `-tags`.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "[]",
				"Status": "",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "env",
				"Type": "map[string]string",
				"Doc": "env adds environment variables to external commands run by `gopls`, most notably `go list`.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "{}",
				"Status": "",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "directoryFilters",
				"Type": "[]string",
				"Doc": "directoryFilters can be used to exclude unwanted directories from the\nworkspace. By default, all directories are included. Filters are an\noperator, `+` to include and `-` to exclude, followed by a path prefix\nrelative to the workspace folder. They are evaluated in order, and\nthe last filter that applies to a path controls whether it is included.\nThe path prefix can be empty, so an initial `-` excludes everything.\n\nDirectoryFilters also supports the `**` operator to match 0 or more directories.\n\nExamples:\n\nExclude node_modules at current depth: `-node_modules`\n\nExclude node_modules at any depth: `-**/node_modules`\n\nInclude only project_a: `-` (exclude everything), `+project_a`\n\nInclude only project_a, but not node_modules inside it: `-`, `+project_a`, `-project_a/node_modules`\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "[\"-**/node_modules\"]",
				"Status": "",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "templateExtensions",
				"Type": "[]string",
				"Doc": "templateExtensions gives the extensions of file names that are treated\nas template files. (The extension\nis the part of the file name after the final dot.)\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "[]",
				"Status": "",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "memoryMode",
				"Type": "string",
				"Doc": "obsolete, no effect\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "\"\"",
				"Status": "experimental",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "expandWorkspaceToModule",
				"Type": "bool",
				"Doc": "expandWorkspaceToModule determines which packages are considered\n\"workspace packages\" when the workspace is using modules.\n\nWorkspace packages affect the scope of workspace-wide operations. Notably,\ngopls diagnoses all packages considered to be part of the workspace after\nevery keystroke, so by setting \"ExpandWorkspaceToModule\" to false, and\nopening a nested workspace directory, you can reduce the amount of work\ngopls has to do to keep your workspace up to date.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "true",
				"Status": "experimental",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "standaloneTags",
				"Type": "[]string",
				"Doc": "standaloneTags specifies a set of build constraints that identify\nindividual Go source files that make up the entire main package of an\nexecutable.\n\nA common example of standalone main files is the convention of using the\ndirective `//go:build ignore` to denote files that are not intended to be\nincluded in any package, for example because they are invoked directly by\nthe developer using `go run`.\n\nGopls considers a file to be a standalone main file if and only if it has\npackage name \"main\" and has a build directive of the exact form\n\"//go:build tag\" or \"// +build tag\", where tag is among the list of tags\nconfigured by this setting. Notably, if the build constraint is more\ncomplicated than a simple tag (such as the composite constraint\n`//go:build tag \u0026\u0026 go1.18`), the file is not considered to be a standalone\nmain file.\n\nThis setting is only supported when gopls is built with Go 1.16 or later.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "[\"ignore\"]",
				"Status": "",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "workspaceFiles",
				"Type": "[]string",
				"Doc": "workspaceFiles configures the set of globs that match files defining the\nlogical build of the current workspace. Any on-disk changes to any files\nmatching a glob specified here will trigger a reload of the workspace.\n\nThis setting need only be customized in environments with a custom\nGOPACKAGESDRIVER.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "[]",
				"Status": "",
				"Hierarchy": "build",
				"DeprecationMessage": ""
			},
			{
				"Name": "hoverKind",
				"Type": "enum",
				"Doc": "hoverKind controls the information that appears in the hover text.\nSingleLine is intended for use only by authors of editor plugins.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"FullDocumentation\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"NoDocumentation\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"SingleLine\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"Structured\"",
						"Doc": "`\"Structured\"` is a misguided experimental setting that returns a JSON\nhover format. This setting should not be used, as it will be removed in a\nfuture release of gopls.\n",
						"Status": ""
					},
					{
						"Value": "\"SynopsisDocumentation\"",
						"Doc": "",
						"Status": ""
					}
				],
				"Default": "\"FullDocumentation\"",
				"Status": "",
				"Hierarchy": "ui.documentation",
				"DeprecationMessage": ""
			},
			{
				"Name": "linkTarget",
				"Type": "string",
				"Doc": "linkTarget is the base URL for links to Go package\ndocumentation returned by LSP operations such as Hover and\nDocumentLinks and in the CodeDescription field of each\nDiagnostic.\n\nIt might be one of:\n\n* `\"godoc.org\"`\n* `\"pkg.go.dev\"`\n\nIf company chooses to use its own `godoc.org`, its address can be used as well.\n\nModules matching the GOPRIVATE environment variable will not have\ndocumentation links in hover.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "\"pkg.go.dev\"",
				"Status": "",
				"Hierarchy": "ui.documentation",
				"DeprecationMessage": ""
			},
			{
				"Name": "linksInHover",
				"Type": "enum",
				"Doc": "linksInHover controls the presence of documentation links in hover markdown.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "false",
						"Doc": "false: do not show links",
						"Status": ""
					},
					{
						"Value": "true",
						"Doc": "true: show links to the `linkTarget` domain",
						"Status": ""
					},
					{
						"Value": "\"gopls\"",
						"Doc": "`\"gopls\"`: show links to gopls' internal documentation viewer",
						"Status": ""
					}
				],
				"Default": "true",
				"Status": "",
				"Hierarchy": "ui.documentation",
				"DeprecationMessage": ""
			},
			{
				"Name": "usePlaceholders",
				"Type": "bool",
				"Doc": "placeholders enables placeholders for function parameters or struct\nfields in completion responses.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "",
				"Hierarchy": "ui.completion",
				"DeprecationMessage": ""
			},
			{
				"Name": "completionBudget",
				"Type": "time.Duration",
				"Doc": "completionBudget is the soft latency goal for completion requests. Most\nrequests finish in a couple milliseconds, but in some cases deep\ncompletions can take much longer. As we use up our budget we\ndynamically reduce the search scope to ensure we return timely\nresults. Zero means unlimited.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "\"100ms\"",
				"Status": "debug",
				"Hierarchy": "ui.completion",
				"DeprecationMessage": ""
			},
			{
				"Name": "matcher",
				"Type": "enum",
				"Doc": "matcher sets the algorithm that is used when calculating completion\ncandidates.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"CaseInsensitive\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"CaseSensitive\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"Fuzzy\"",
						"Doc": "",
						"Status": ""
					}
				],
				"Default": "\"Fuzzy\"",
				"Status": "advanced",
				"Hierarchy": "ui.completion",
				"DeprecationMessage": ""
			},
			{
				"Name": "experimentalPostfixCompletions",
				"Type": "bool",
				"Doc": "experimentalPostfixCompletions enables artificial method snippets\nsuch as \"someSlice.sort!\".\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "true",
				"Status": "experimental",
				"Hierarchy": "ui.completion",
				"DeprecationMessage": ""
			},
			{
				"Name": "completeFunctionCalls",
				"Type": "bool",
				"Doc": "completeFunctionCalls enables function call completion.\n\nWhen completing a statement, or when a function return type matches the\nexpected of the expression being completed, completion may suggest call\nexpressions (i.e. may include parentheses).\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "true",
				"Status": "",
				"Hierarchy": "ui.completion",
				"DeprecationMessage": ""
			},
			{
				"Name": "importShortcut",
				"Type": "enum",
				"Doc": "importShortcut specifies whether import statements should link to\ndocumentation or go to definitions.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"Both\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"Definition\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"Link\"",
						"Doc": "",
						"Status": ""
					}
				],
				"Default": "\"Both\"",
				"Status": "",
				"Hierarchy": "ui.navigation",
				"DeprecationMessage": ""
			},
			{
				"Name": "symbolMatcher",
				"Type": "enum",
				"Doc": "symbolMatcher sets the algorithm that is used when finding workspace symbols.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"CaseInsensitive\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"CaseSensitive\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"FastFuzzy\"",
						"Doc": "",
						"Status": ""
					},
					{
						"Value": "\"Fuzzy\"",
						"Doc": "",
						"Status": ""
					}
				],
				"Default": "\"FastFuzzy\"",
				"Status": "advanced",
				"Hierarchy": "ui.navigation",
				"DeprecationMessage": ""
			},
			{
				"Name": "symbolStyle",
				"Type": "enum",
				"Doc": "symbolStyle controls how symbols are qualified in symbol responses.\n\nExample Usage:\n\n```json5\n\"gopls\": {\n...\n  \"symbolStyle\": \"Dynamic\",\n...\n}\n```\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"Dynamic\"",
						"Doc": "`\"Dynamic\"` uses whichever qualifier results in the highest scoring\nmatch for the given symbol query. Here a \"qualifier\" is any \"/\" or \".\"\ndelimited suffix of the fully qualified symbol. i.e. \"to/pkg.Foo.Field\" or\njust \"Foo.Field\".\n",
						"Status": ""
					},
					{
						"Value": "\"Full\"",
						"Doc": "`\"Full\"` is fully qualified symbols, i.e.\n\"path/to/pkg.Foo.Field\".\n",
						"Status": ""
					},
					{
						"Value": "\"Package\"",
						"Doc": "`\"Package\"` is package qualified symbols i.e.\n\"pkg.Foo.Field\".\n",
						"Status": ""
					}
				],
				"Default": "\"Dynamic\"",
				"Status": "advanced",
				"Hierarchy": "ui.navigation",
				"DeprecationMessage": ""
			},
			{
				"Name": "symbolScope",
				"Type": "enum",
				"Doc": "symbolScope controls which packages are searched for workspace/symbol\nrequests. When the scope is \"workspace\", gopls searches only workspace\npackages. When the scope is \"all\", gopls searches all loaded packages,\nincluding dependencies and the standard library.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"all\"",
						"Doc": "`\"all\"` matches symbols in any loaded package, including\ndependencies.\n",
						"Status": ""
					},
					{
						"Value": "\"workspace\"",
						"Doc": "`\"workspace\"` matches symbols in workspace packages only.\n",
						"Status": ""
					}
				],
				"Default": "\"all\"",
				"Status": "",
				"Hierarchy": "ui.navigation",
				"DeprecationMessage": ""
			},
			{
				"Name": "analyses",
				"Type": "map[string]bool",
				"Doc": "analyses specify analyses that the user would like to enable or disable.\nA map of the names of analysis passes that should be enabled/disabled.\nA full list of analyzers that gopls uses can be found in\n[analyzers.md](https://github.com/golang/tools/blob/master/gopls/doc/analyzers.md).\n\nExample Usage:\n\n```json5\n...\n\"analyses\": {\n  \"unreachable\": false, // Disable the unreachable analyzer.\n  \"unusedvariable\": true  // Enable the unusedvariable analyzer.\n}\n...\n```\n",
				"EnumKeys": {
					"ValueType": "bool",
					"Keys": [
						{
							"Name": "\"QF1001\"",
							"Doc": "Apply De Morgan's law\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"QF1002\"",
							"Doc": "Convert untagged switch to tagged switch\n\nAn untagged switch that compares a single variable against a series of\nvalues can be replaced with a tagged switch.\n\nBefore:\n\n    switch {\n    case x == 1 || x == 2, x == 3:\n        ...\n    case x == 4:\n        ...\n    default:\n        ...\n    }\n\nAfter:\n\n    switch x {\n    case 1, 2, 3:\n        ...\n    case 4:\n        ...\n    default:\n        ...\n    }\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"QF1003\"",
							"Doc": "Convert if/else-if chain to tagged switch\n\nA series of if/else-if checks comparing the same variable against\nvalues can be replaced with a tagged switch.\n\nBefore:\n\n    if x == 1 || x == 2 {\n        ...\n    } else if x == 3 {\n        ...\n    } else {\n        ...\n    }\n\nAfter:\n\n    switch x {\n    case 1, 2:\n        ...\n    case 3:\n        ...\n    default:\n        ...\n    }\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"QF1004\"",
							"Doc": "Use strings.ReplaceAll instead of strings.Replace with n == -1\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"QF1005\"",
							"Doc": "Expand call to math.Pow\n\nSome uses of math.Pow can be simplified to basic multiplication.\n\nBefore:\n\n    math.Pow(x, 2)\n\nAfter:\n\n    x * x\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"QF1006\"",
							"Doc": "Lift if+break into loop condition\n\nBefore:\n\n    for {\n        if done {\n            break\n        }\n        ...\n    }\n\nAfter:\n\n    for !done {\n        ...\n    }\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"QF1007\"",
							"Doc": "Merge conditional assignment into variable declaration\n\nBefore:\n\n    x := false\n    if someCondition {\n        x = true\n    }\n\nAfter:\n\n    x := someCondition\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"QF1008\"",
							"Doc": "Omit embedded fields from selector expression\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"QF1009\"",
							"Doc": "Use time.Time.Equal instead of == operator\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"QF1010\"",
							"Doc": "Convert slice of bytes to string when printing it\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"QF1011\"",
							"Doc": "Omit redundant type from variable declaration\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"QF1012\"",
							"Doc": "Use fmt.Fprintf(x, ...) instead of x.Write(fmt.Sprintf(...))\n\nAvailable since\n    2022.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1000\"",
							"Doc": "Use plain channel send or receive instead of single-case select\n\nSelect statements with a single case can be replaced with a simple\nsend or receive.\n\nBefore:\n\n    select {\n    case x := \u003c-ch:\n        fmt.Println(x)\n    }\n\nAfter:\n\n    x := \u003c-ch\n    fmt.Println(x)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1001\"",
							"Doc": "Replace for loop with call to copy\n\nUse copy() for copying elements from one slice to another. For\narrays of identical size, you can use simple assignment.\n\nBefore:\n\n    for i, x := range src {\n        dst[i] = x\n    }\n\nAfter:\n\n    copy(dst, src)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1002\"",
							"Doc": "Omit comparison with boolean constant\n\nBefore:\n\n    if x == true {}\n\nAfter:\n\n    if x {}\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1003\"",
							"Doc": "Replace call to strings.Index with strings.Contains\n\nBefore:\n\n    if strings.Index(x, y) != -1 {}\n\nAfter:\n\n    if strings.Contains(x, y) {}\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1004\"",
							"Doc": "Replace call to bytes.Compare with bytes.Equal\n\nBefore:\n\n    if bytes.Compare(x, y) == 0 {}\n\nAfter:\n\n    if bytes.Equal(x, y) {}\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1005\"",
							"Doc": "Drop unnecessary use of the blank identifier\n\nIn many cases, assigning to the blank identifier is unnecessary.\n\nBefore:\n\n    for _ = range s {}\n    x, _ = someMap[key]\n    _ = \u003c-ch\n\nAfter:\n\n    for range s{}\n    x = someMap[key]\n    \u003c-ch\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1006\"",
							"Doc": "Use 'for { ... }' for infinite loops\n\nFor infinite loops, using for { ... } is the most idiomatic choice.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1007\"",
							"Doc": "Simplify regular expression by using raw string literal\n\nRaw string literals use backticks instead of quotation marks and do not support\nany escape sequences. This means that the backslash can be used\nfreely, without the need of escaping.\n\nSince regular expressions have their own escape sequences, raw strings\ncan improve their readability.\n\nBefore:\n\n    regexp.Compile(\"\\\\A(\\\\w+) profile: total \\\\d+\\\\n\\\\z\")\n\nAfter:\n\n    regexp.Compile(`\\A(\\w+) profile: total \\d+\\n\\z`)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1008\"",
							"Doc": "Simplify returning boolean expression\n\nBefore:\n\n    if \u003cexpr\u003e {\n        return true\n    }\n    return false\n\nAfter:\n\n    return \u003cexpr\u003e\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1009\"",
							"Doc": "Omit redundant nil check on slices, maps, and channels\n\nThe len function is defined for all slices, maps, and\nchannels, even nil ones, which have a length of zero. It is not necessary to\ncheck for nil before checking that their length is not zero.\n\nBefore:\n\n    if x != nil \u0026\u0026 len(x) != 0 {}\n\nAfter:\n\n    if len(x) != 0 {}\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1010\"",
							"Doc": "Omit default slice index\n\nWhen slicing, the second index defaults to the length of the value,\nmaking s[n:len(s)] and s[n:] equivalent.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1011\"",
							"Doc": "Use a single append to concatenate two slices\n\nBefore:\n\n    for _, e := range y {\n        x = append(x, e)\n    }\n    \n    for i := range y {\n        x = append(x, y[i])\n    }\n    \n    for i := range y {\n        v := y[i]\n        x = append(x, v)\n    }\n\nAfter:\n\n    x = append(x, y...)\n    x = append(x, y...)\n    x = append(x, y...)\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1012\"",
							"Doc": "Replace time.Now().Sub(x) with time.Since(x)\n\nThe time.Since helper has the same effect as using time.Now().Sub(x)\nbut is easier to read.\n\nBefore:\n\n    time.Now().Sub(x)\n\nAfter:\n\n    time.Since(x)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1016\"",
							"Doc": "Use a type conversion instead of manually copying struct fields\n\nTwo struct types with identical fields can be converted between each\nother. In older versions of Go, the fields had to have identical\nstruct tags. Since Go 1.8, however, struct tags are ignored during\nconversions. It is thus not necessary to manually copy every field\nindividually.\n\nBefore:\n\n    var x T1\n    y := T2{\n        Field1: x.Field1,\n        Field2: x.Field2,\n    }\n\nAfter:\n\n    var x T1\n    y := T2(x)\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1017\"",
							"Doc": "Replace manual trimming with strings.TrimPrefix\n\nInstead of using strings.HasPrefix and manual slicing, use the\nstrings.TrimPrefix function. If the string doesn't start with the\nprefix, the original string will be returned. Using strings.TrimPrefix\nreduces complexity, and avoids common bugs, such as off-by-one\nmistakes.\n\nBefore:\n\n    if strings.HasPrefix(str, prefix) {\n        str = str[len(prefix):]\n    }\n\nAfter:\n\n    str = strings.TrimPrefix(str, prefix)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1018\"",
							"Doc": "Use 'copy' for sliding elements\n\ncopy() permits using the same source and destination slice, even with\noverlapping ranges. This makes it ideal for sliding elements in a\nslice.\n\nBefore:\n\n    for i := 0; i \u003c n; i++ {\n        bs[i] = bs[offset+i]\n    }\n\nAfter:\n\n    copy(bs[:n], bs[offset:])\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1019\"",
							"Doc": "Simplify 'make' call by omitting redundant arguments\n\nThe 'make' function has default values for the length and capacity\narguments. For channels, the length defaults to zero, and for slices,\nthe capacity defaults to the length.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1020\"",
							"Doc": "Omit redundant nil check in type assertion\n\nBefore:\n\n    if _, ok := i.(T); ok \u0026\u0026 i != nil {}\n\nAfter:\n\n    if _, ok := i.(T); ok {}\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1021\"",
							"Doc": "Merge variable declaration and assignment\n\nBefore:\n\n    var x uint\n    x = 1\n\nAfter:\n\n    var x uint = 1\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1023\"",
							"Doc": "Omit redundant control flow\n\nFunctions that have no return value do not need a return statement as\nthe final statement of the function.\n\nSwitches in Go do not have automatic fallthrough, unlike languages\nlike C. It is not necessary to have a break statement as the final\nstatement in a case block.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1024\"",
							"Doc": "Replace x.Sub(time.Now()) with time.Until(x)\n\nThe time.Until helper has the same effect as using x.Sub(time.Now())\nbut is easier to read.\n\nBefore:\n\n    x.Sub(time.Now())\n\nAfter:\n\n    time.Until(x)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1025\"",
							"Doc": "Don't use fmt.Sprintf(\"%s\", x) unnecessarily\n\nIn many instances, there are easier and more efficient ways of getting\na value's string representation. Whenever a value's underlying type is\na string already, or the type has a String method, they should be used\ndirectly.\n\nGiven the following shared definitions\n\n    type T1 string\n    type T2 int\n\n    func (T2) String() string { return \"Hello, world\" }\n\n    var x string\n    var y T1\n    var z T2\n\nwe can simplify\n\n    fmt.Sprintf(\"%s\", x)\n    fmt.Sprintf(\"%s\", y)\n    fmt.Sprintf(\"%s\", z)\n\nto\n\n    x\n    string(y)\n    z.String()\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1028\"",
							"Doc": "Simplify error construction with fmt.Errorf\n\nBefore:\n\n    errors.New(fmt.Sprintf(...))\n\nAfter:\n\n    fmt.Errorf(...)\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1029\"",
							"Doc": "Range over the string directly\n\nRanging over a string will yield byte offsets and runes. If the offset\nisn't used, this is functionally equivalent to converting the string\nto a slice of runes and ranging over that. Ranging directly over the\nstring will be more performant, however, as it avoids allocating a new\nslice, the size of which depends on the length of the string.\n\nBefore:\n\n    for _, r := range []rune(s) {}\n\nAfter:\n\n    for _, r := range s {}\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"S1030\"",
							"Doc": "Use bytes.Buffer.String or bytes.Buffer.Bytes\n\nbytes.Buffer has both a String and a Bytes method. It is almost never\nnecessary to use string(buf.Bytes()) or []byte(buf.String()) – simply\nuse the other method.\n\nThe only exception to this are map lookups. Due to a compiler optimization,\nm[string(buf.Bytes())] is more efficient than m[buf.String()].\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1031\"",
							"Doc": "Omit redundant nil check around loop\n\nYou can use range on nil slices and maps, the loop will simply never\nexecute. This makes an additional nil check around the loop\nunnecessary.\n\nBefore:\n\n    if s != nil {\n        for _, x := range s {\n            ...\n        }\n    }\n\nAfter:\n\n    for _, x := range s {\n        ...\n    }\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1032\"",
							"Doc": "Use sort.Ints(x), sort.Float64s(x), and sort.Strings(x)\n\nThe sort.Ints, sort.Float64s and sort.Strings functions are easier to\nread than sort.Sort(sort.IntSlice(x)), sort.Sort(sort.Float64Slice(x))\nand sort.Sort(sort.StringSlice(x)).\n\nBefore:\n\n    sort.Sort(sort.StringSlice(x))\n\nAfter:\n\n    sort.Strings(x)\n\nAvailable since\n    2019.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1033\"",
							"Doc": "Unnecessary guard around call to 'delete'\n\nCalling delete on a nil map is a no-op.\n\nAvailable since\n    2019.2\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1034\"",
							"Doc": "Use result of type assertion to simplify cases\n\nAvailable since\n    2019.2\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1035\"",
							"Doc": "Redundant call to net/http.CanonicalHeaderKey in method call on net/http.Header\n\nThe methods on net/http.Header, namely Add, Del, Get\nand Set, already canonicalize the given header name.\n\nAvailable since\n    2020.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1036\"",
							"Doc": "Unnecessary guard around map access\n\nWhen accessing a map key that doesn't exist yet, one receives a zero\nvalue. Often, the zero value is a suitable value, for example when\nusing append or doing integer math.\n\nThe following\n\n    if _, ok := m[\"foo\"]; ok {\n        m[\"foo\"] = append(m[\"foo\"], \"bar\")\n    } else {\n        m[\"foo\"] = []string{\"bar\"}\n    }\n\ncan be simplified to\n\n    m[\"foo\"] = append(m[\"foo\"], \"bar\")\n\nand\n\n    if _, ok := m2[\"k\"]; ok {\n        m2[\"k\"] += 4\n    } else {\n        m2[\"k\"] = 4\n    }\n\ncan be simplified to\n\n    m[\"k\"] += 4\n\nAvailable since\n    2020.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1037\"",
							"Doc": "Elaborate way of sleeping\n\nUsing a select statement with a single case receiving\nfrom the result of time.After is a very elaborate way of sleeping that\ncan much simpler be expressed with a simple call to time.Sleep.\n\nAvailable since\n    2020.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1038\"",
							"Doc": "Unnecessarily complex way of printing formatted string\n\nInstead of using fmt.Print(fmt.Sprintf(...)), one can use fmt.Printf(...).\n\nAvailable since\n    2020.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1039\"",
							"Doc": "Unnecessary use of fmt.Sprint\n\nCalling fmt.Sprint with a single string argument is unnecessary\nand identical to using the string directly.\n\nAvailable since\n    2020.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"S1040\"",
							"Doc": "Type assertion to current type\n\nThe type assertion x.(SomeInterface), when x already has type\nSomeInterface, can only fail if x is nil. Usually, this is\nleft-over code from when x had a different type and you can safely\ndelete the type assertion. If you want to check that x is not nil,\nconsider being explicit and using an actual if x == nil comparison\ninstead of relying on the type assertion panicking.\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1000\"",
							"Doc": "Invalid regular expression\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1001\"",
							"Doc": "Invalid template\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1002\"",
							"Doc": "Invalid format in time.Parse\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1003\"",
							"Doc": "Unsupported argument to functions in encoding/binary\n\nThe encoding/binary package can only serialize types with known sizes.\nThis precludes the use of the int and uint types, as their sizes\ndiffer on different architectures. Furthermore, it doesn't support\nserializing maps, channels, strings, or functions.\n\nBefore Go 1.8, bool wasn't supported, either.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1004\"",
							"Doc": "Suspiciously small untyped constant in time.Sleep\n\nThe time.Sleep function takes a time.Duration as its only argument.\nDurations are expressed in nanoseconds. Thus, calling time.Sleep(1)\nwill sleep for 1 nanosecond. This is a common source of bugs, as sleep\nfunctions in other languages often accept seconds or milliseconds.\n\nThe time package provides constants such as time.Second to express\nlarge durations. These can be combined with arithmetic to express\narbitrary durations, for example 5 * time.Second for 5 seconds.\n\nIf you truly meant to sleep for a tiny amount of time, use\nn * time.Nanosecond to signal to Staticcheck that you did mean to sleep\nfor some amount of nanoseconds.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1005\"",
							"Doc": "Invalid first argument to exec.Command\n\nos/exec runs programs directly (using variants of the fork and exec\nsystem calls on Unix systems). This shouldn't be confused with running\na command in a shell. The shell will allow for features such as input\nredirection, pipes, and general scripting. The shell is also\nresponsible for splitting the user's input into a program name and its\narguments. For example, the equivalent to\n\n    ls / /tmp\n\nwould be\n\n    exec.Command(\"ls\", \"/\", \"/tmp\")\n\nIf you want to run a command in a shell, consider using something like\nthe following – but be aware that not all systems, particularly\nWindows, will have a /bin/sh program:\n\n    exec.Command(\"/bin/sh\", \"-c\", \"ls | grep Awesome\")\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1007\"",
							"Doc": "Invalid URL in net/url.Parse\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1008\"",
							"Doc": "Non-canonical key in http.Header map\n\nKeys in http.Header maps are canonical, meaning they follow a specific\ncombination of uppercase and lowercase letters. Methods such as\nhttp.Header.Add and http.Header.Del convert inputs into this canonical\nform before manipulating the map.\n\nWhen manipulating http.Header maps directly, as opposed to using the\nprovided methods, care should be taken to stick to canonical form in\norder to avoid inconsistencies. The following piece of code\ndemonstrates one such inconsistency:\n\n    h := http.Header{}\n    h[\"etag\"] = []string{\"1234\"}\n    h.Add(\"etag\", \"5678\")\n    fmt.Println(h)\n\n    // Output:\n    // map[Etag:[5678] etag:[1234]]\n\nThe easiest way of obtaining the canonical form of a key is to use\nhttp.CanonicalHeaderKey.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1010\"",
							"Doc": "(*regexp.Regexp).FindAll called with n == 0, which will always return zero results\n\nIf n \u003e= 0, the function returns at most n matches/submatches. To\nreturn all results, specify a negative number.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1011\"",
							"Doc": "Various methods in the 'strings' package expect valid UTF-8, but invalid input is provided\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1012\"",
							"Doc": "A nil context.Context is being passed to a function, consider using context.TODO instead\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1013\"",
							"Doc": "io.Seeker.Seek is being called with the whence constant as the first argument, but it should be the second\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1014\"",
							"Doc": "Non-pointer value passed to Unmarshal or Decode\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1015\"",
							"Doc": "Using time.Tick in a way that will leak. Consider using time.NewTicker, and only use time.Tick in tests, commands and endless functions\n\nBefore Go 1.23, time.Tickers had to be closed to be able to be garbage\ncollected. Since time.Tick doesn't make it possible to close the underlying\nticker, using it repeatedly would leak memory.\n\nGo 1.23 fixes this by allowing tickers to be collected even if they weren't closed.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1016\"",
							"Doc": "Trapping a signal that cannot be trapped\n\nNot all signals can be intercepted by a process. Specifically, on\nUNIX-like systems, the syscall.SIGKILL and syscall.SIGSTOP signals are\nnever passed to the process, but instead handled directly by the\nkernel. It is therefore pointless to try and handle these signals.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA1017\"",
							"Doc": "Channels used with os/signal.Notify should be buffered\n\nThe os/signal package uses non-blocking channel sends when delivering\nsignals. If the receiving end of the channel isn't ready and the\nchannel is either unbuffered or full, the signal will be dropped. To\navoid missing signals, the channel should be buffered and of the\nappropriate size. For a channel used for notification of just one\nsignal value, a buffer of size 1 is sufficient.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1018\"",
							"Doc": "strings.Replace called with n == 0, which does nothing\n\nWith n == 0, zero instances will be replaced. To replace all\ninstances, use a negative number, or use strings.ReplaceAll.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1020\"",
							"Doc": "Using an invalid host:port pair with a net.Listen-related function\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1021\"",
							"Doc": "Using bytes.Equal to compare two net.IP\n\nA net.IP stores an IPv4 or IPv6 address as a slice of bytes. The\nlength of the slice for an IPv4 address, however, can be either 4 or\n16 bytes long, using different ways of representing IPv4 addresses. In\norder to correctly compare two net.IPs, the net.IP.Equal method should\nbe used, as it takes both representations into account.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1023\"",
							"Doc": "Modifying the buffer in an io.Writer implementation\n\nWrite must not modify the slice data, even temporarily.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1024\"",
							"Doc": "A string cutset contains duplicate characters\n\nThe strings.TrimLeft and strings.TrimRight functions take cutsets, not\nprefixes. A cutset is treated as a set of characters to remove from a\nstring. For example,\n\n    strings.TrimLeft(\"42133word\", \"1234\")\n\nwill result in the string \"word\" – any characters that are 1, 2, 3 or\n4 are cut from the left of the string.\n\nIn order to remove one string from another, use strings.TrimPrefix instead.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1025\"",
							"Doc": "It is not possible to use (*time.Timer).Reset's return value correctly\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1026\"",
							"Doc": "Cannot marshal channels or functions\n\nAvailable since\n    2019.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1027\"",
							"Doc": "Atomic access to 64-bit variable must be 64-bit aligned\n\nOn ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to\narrange for 64-bit alignment of 64-bit words accessed atomically. The\nfirst word in a variable or in an allocated struct, array, or slice\ncan be relied upon to be 64-bit aligned.\n\nYou can use the structlayout tool to inspect the alignment of fields\nin a struct.\n\nAvailable since\n    2019.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1028\"",
							"Doc": "sort.Slice can only be used on slices\n\nThe first argument of sort.Slice must be a slice.\n\nAvailable since\n    2020.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1029\"",
							"Doc": "Inappropriate key in call to context.WithValue\n\nThe provided key must be comparable and should not be\nof type string or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys.\n\nTo avoid allocating when assigning to an interface{},\ncontext keys often have concrete type struct{}. Alternatively,\nexported context key variables' static type should be a pointer or\ninterface.\n\nAvailable since\n    2020.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1030\"",
							"Doc": "Invalid argument in call to a strconv function\n\nThis check validates the format, number base and bit size arguments of\nthe various parsing and formatting functions in strconv.\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1031\"",
							"Doc": "Overlapping byte slices passed to an encoder\n\nIn an encoding function of the form Encode(dst, src), dst and\nsrc were found to reference the same memory. This can result in\nsrc bytes being overwritten before they are read, when the encoder\nwrites more than one byte per src byte.\n\nAvailable since\n    2024.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA1032\"",
							"Doc": "Wrong order of arguments to errors.Is\n\nThe first argument of the function errors.Is is the error\nthat we have and the second argument is the error we're trying to match against.\nFor example:\n\n\tif errors.Is(err, io.EOF) { ... }\n\nThis check detects some cases where the two arguments have been swapped. It\nflags any calls where the first argument is referring to a package-level error\nvariable, such as\n\n\tif errors.Is(io.EOF, err) { /* this is wrong */ }\n\nAvailable since\n    2024.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA2001\"",
							"Doc": "Empty critical section, did you mean to defer the unlock?\n\nEmpty critical sections of the kind\n\n    mu.Lock()\n    mu.Unlock()\n\nare very often a typo, and the following was intended instead:\n\n    mu.Lock()\n    defer mu.Unlock()\n\nDo note that sometimes empty critical sections can be useful, as a\nform of signaling to wait on another goroutine. Many times, there are\nsimpler ways of achieving the same effect. When that isn't the case,\nthe code should be amply commented to avoid confusion. Combining such\ncomments with a //lint:ignore directive can be used to suppress this\nrare false positive.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA2002\"",
							"Doc": "Called testing.T.FailNow or SkipNow in a goroutine, which isn't allowed\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA2003\"",
							"Doc": "Deferred Lock right after locking, likely meant to defer Unlock instead\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA3000\"",
							"Doc": "TestMain doesn't call os.Exit, hiding test failures\n\nTest executables (and in turn 'go test') exit with a non-zero status\ncode if any tests failed. When specifying your own TestMain function,\nit is your responsibility to arrange for this, by calling os.Exit with\nthe correct code. The correct code is returned by (*testing.M).Run, so\nthe usual way of implementing TestMain is to end it with\nos.Exit(m.Run()).\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA3001\"",
							"Doc": "Assigning to b.N in benchmarks distorts the results\n\nThe testing package dynamically sets b.N to improve the reliability of\nbenchmarks and uses it in computations to determine the duration of a\nsingle operation. Benchmark code must not alter b.N as this would\nfalsify results.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4000\"",
							"Doc": "Binary operator has identical expressions on both sides\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4001\"",
							"Doc": "\u0026*x gets simplified to x, it does not copy x\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4003\"",
							"Doc": "Comparing unsigned values against negative values is pointless\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4004\"",
							"Doc": "The loop exits unconditionally after one iteration\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4005\"",
							"Doc": "Field assignment that will never be observed. Did you mean to use a pointer receiver?\n\nAvailable since\n    2021.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4006\"",
							"Doc": "A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4008\"",
							"Doc": "The variable in the loop condition never changes, are you incrementing the wrong variable?\n\nFor example:\n\n\tfor i := 0; i \u003c 10; j++ { ... }\n\nThis may also occur when a loop can only execute once because of unconditional\ncontrol flow that terminates the loop. For example, when a loop body contains an\nunconditional break, return, or panic:\n\n\tfunc f() {\n\t\tpanic(\"oops\")\n\t}\n\tfunc g() {\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\t// f unconditionally calls panic, which means \"i\" is\n\t\t\t// never incremented.\n\t\t\tf()\n\t\t}\n\t}\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4009\"",
							"Doc": "A function argument is overwritten before its first use\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4010\"",
							"Doc": "The result of append will never be observed anywhere\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4011\"",
							"Doc": "Break statement with no effect. Did you mean to break out of an outer loop?\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4012\"",
							"Doc": "Comparing a value against NaN even though no value is equal to NaN\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4013\"",
							"Doc": "Negating a boolean twice (!!b) is the same as writing b. This is either redundant, or a typo.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4014\"",
							"Doc": "An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4015\"",
							"Doc": "Calling functions like math.Ceil on floats converted from integers doesn't do anything useful\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4016\"",
							"Doc": "Certain bitwise operations, such as x ^ 0, do not do anything useful\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4017\"",
							"Doc": "Discarding the return values of a function without side effects, making the call pointless\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4018\"",
							"Doc": "Self-assignment of variables\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4019\"",
							"Doc": "Multiple, identical build constraints in the same file\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4020\"",
							"Doc": "Unreachable case clause in a type switch\n\nIn a type switch like the following\n\n    type T struct{}\n    func (T) Read(b []byte) (int, error) { return 0, nil }\n\n    var v any = T{}\n\n    switch v.(type) {\n    case io.Reader:\n        // ...\n    case T:\n        // unreachable\n    }\n\nthe second case clause can never be reached because T implements\nio.Reader and case clauses are evaluated in source order.\n\nAnother example:\n\n    type T struct{}\n    func (T) Read(b []byte) (int, error) { return 0, nil }\n    func (T) Close() error { return nil }\n\n    var v any = T{}\n\n    switch v.(type) {\n    case io.Reader:\n        // ...\n    case io.ReadCloser:\n        // unreachable\n    }\n\nEven though T has a Close method and thus implements io.ReadCloser,\nio.Reader will always match first. The method set of io.Reader is a\nsubset of io.ReadCloser. Thus it is impossible to match the second\ncase without matching the first case.\n\n\nStructurally equivalent interfaces\n\nA special case of the previous example are structurally identical\ninterfaces. Given these declarations\n\n    type T error\n    type V error\n\n    func doSomething() error {\n        err, ok := doAnotherThing()\n        if ok {\n            return T(err)\n        }\n\n        return U(err)\n    }\n\nthe following type switch will have an unreachable case clause:\n\n    switch doSomething().(type) {\n    case T:\n        // ...\n    case V:\n        // unreachable\n    }\n\nT will always match before V because they are structurally equivalent\nand therefore doSomething()'s return value implements both.\n\nAvailable since\n    2019.2\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4022\"",
							"Doc": "Comparing the address of a variable against nil\n\nCode such as 'if \u0026x == nil' is meaningless, because taking the address of a variable always yields a non-nil pointer.\n\nAvailable since\n    2020.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4023\"",
							"Doc": "Impossible comparison of interface value with untyped nil\n\nUnder the covers, interfaces are implemented as two elements, a\ntype T and a value V. V is a concrete value such as an int,\nstruct or pointer, never an interface itself, and has type T. For\ninstance, if we store the int value 3 in an interface, the\nresulting interface value has, schematically, (T=int, V=3). The\nvalue V is also known as the interface's dynamic value, since a\ngiven interface variable might hold different values V (and\ncorresponding types T) during the execution of the program.\n\nAn interface value is nil only if the V and T are both\nunset, (T=nil, V is not set), In particular, a nil interface will\nalways hold a nil type. If we store a nil pointer of type *int\ninside an interface value, the inner type will be *int regardless\nof the value of the pointer: (T=*int, V=nil). Such an interface\nvalue will therefore be non-nil even when the pointer value V\ninside is nil.\n\nThis situation can be confusing, and arises when a nil value is\nstored inside an interface value such as an error return:\n\n    func returnsError() error {\n        var p *MyError = nil\n        if bad() {\n            p = ErrBad\n        }\n        return p // Will always return a non-nil error.\n    }\n\nIf all goes well, the function returns a nil p, so the return\nvalue is an error interface value holding (T=*MyError, V=nil).\nThis means that if the caller compares the returned error to nil,\nit will always look as if there was an error even if nothing bad\nhappened. To return a proper nil error to the caller, the\nfunction must return an explicit nil:\n\n    func returnsError() error {\n        if bad() {\n            return ErrBad\n        }\n        return nil\n    }\n\nIt's a good idea for functions that return errors always to use\nthe error type in their signature (as we did above) rather than a\nconcrete type such as *MyError, to help guarantee the error is\ncreated correctly. As an example, os.Open returns an error even\nthough, if not nil, it's always of concrete type *os.PathError.\n\nSimilar situations to those described here can arise whenever\ninterfaces are used. Just keep in mind that if any concrete value\nhas been stored in the interface, the interface will not be nil.\nFor more information, see The Laws of\nReflection at https://golang.org/doc/articles/laws_of_reflection.html.\n\nThis text has been copied from\nhttps://golang.org/doc/faq#nil_error, licensed under the Creative\nCommons Attribution 3.0 License.\n\nAvailable since\n    2020.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4024\"",
							"Doc": "Checking for impossible return value from a builtin function\n\nReturn values of the len and cap builtins cannot be negative.\n\nSee https://golang.org/pkg/builtin/#len and https://golang.org/pkg/builtin/#cap.\n\nExample:\n\n    if len(slice) \u003c 0 {\n        fmt.Println(\"unreachable code\")\n    }\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4025\"",
							"Doc": "Integer division of literals that results in zero\n\nWhen dividing two integer constants, the result will\nalso be an integer. Thus, a division such as 2 / 3 results in 0.\nThis is true for all of the following examples:\n\n\t_ = 2 / 3\n\tconst _ = 2 / 3\n\tconst _ float64 = 2 / 3\n\t_ = float64(2 / 3)\n\nStaticcheck will flag such divisions if both sides of the division are\ninteger literals, as it is highly unlikely that the division was\nintended to truncate to zero. Staticcheck will not flag integer\ndivision involving named constants, to avoid noisy positives.\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4026\"",
							"Doc": "Go constants cannot express negative zero\n\nIn IEEE 754 floating point math, zero has a sign and can be positive\nor negative. This can be useful in certain numerical code.\n\nGo constants, however, cannot express negative zero. This means that\nthe literals -0.0 and 0.0 have the same ideal value (zero) and\nwill both represent positive zero at runtime.\n\nTo explicitly and reliably create a negative zero, you can use the\nmath.Copysign function: math.Copysign(0, -1).\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4027\"",
							"Doc": "(*net/url.URL).Query returns a copy, modifying it doesn't change the URL\n\n(*net/url.URL).Query parses the current value of net/url.URL.RawQuery\nand returns it as a map of type net/url.Values. Subsequent changes to\nthis map will not affect the URL unless the map gets encoded and\nassigned to the URL's RawQuery.\n\nAs a consequence, the following code pattern is an expensive no-op:\nu.Query().Add(key, value).\n\nAvailable since\n    2021.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4028\"",
							"Doc": "x % 1 is always zero\n\nAvailable since\n    2022.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4029\"",
							"Doc": "Ineffective attempt at sorting slice\n\nsort.Float64Slice, sort.IntSlice, and sort.StringSlice are\ntypes, not functions. Doing x = sort.StringSlice(x) does nothing,\nespecially not sort any values. The correct usage is\nsort.Sort(sort.StringSlice(x)) or sort.StringSlice(x).Sort(),\nbut there are more convenient helpers, namely sort.Float64s,\nsort.Ints, and sort.Strings.\n\nAvailable since\n    2022.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4030\"",
							"Doc": "Ineffective attempt at generating random number\n\nFunctions in the math/rand package that accept upper limits, such\nas Intn, generate random numbers in the half-open interval [0,n). In\nother words, the generated numbers will be \u003e= 0 and \u003c n – they\ndon't include n. rand.Intn(1) therefore doesn't generate 0\nor 1, it always generates 0.\n\nAvailable since\n    2022.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA4031\"",
							"Doc": "Checking never-nil value against nil\n\nAvailable since\n    2022.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA4032\"",
							"Doc": "Comparing runtime.GOOS or runtime.GOARCH against impossible value\n\nAvailable since\n    2024.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA5000\"",
							"Doc": "Assignment to nil map\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA5001\"",
							"Doc": "Deferring Close before checking for a possible error\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA5002\"",
							"Doc": "The empty for loop ('for {}') spins and can block the scheduler\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA5003\"",
							"Doc": "Defers in infinite loops will never execute\n\nDefers are scoped to the surrounding function, not the surrounding\nblock. In a function that never returns, i.e. one containing an\ninfinite loop, defers will never execute.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA5004\"",
							"Doc": "'for { select { ...' with an empty default branch spins\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA5005\"",
							"Doc": "The finalizer references the finalized object, preventing garbage collection\n\nA finalizer is a function associated with an object that runs when the\ngarbage collector is ready to collect said object, that is when the\nobject is no longer referenced by anything.\n\nIf the finalizer references the object, however, it will always remain\nas the final reference to that object, preventing the garbage\ncollector from collecting the object. The finalizer will never run,\nand the object will never be collected, leading to a memory leak. That\nis why the finalizer should instead use its first argument to operate\non the object. That way, the number of references can temporarily go\nto zero before the object is being passed to the finalizer.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA5007\"",
							"Doc": "Infinite recursive call\n\nA function that calls itself recursively needs to have an exit\ncondition. Otherwise it will recurse forever, until the system runs\nout of memory.\n\nThis issue can be caused by simple bugs such as forgetting to add an\nexit condition. It can also happen \"on purpose\". Some languages have\ntail call optimization which makes certain infinite recursive calls\nsafe to use. Go, however, does not implement TCO, and as such a loop\nshould be used instead.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA5008\"",
							"Doc": "Invalid struct tag\n\nAvailable since\n    2019.2\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA5010\"",
							"Doc": "Impossible type assertion\n\nSome type assertions can be statically proven to be\nimpossible. This is the case when the method sets of both\narguments of the type assertion conflict with each other, for\nexample by containing the same method with different\nsignatures.\n\nThe Go compiler already applies this check when asserting from an\ninterface value to a concrete type. If the concrete type misses\nmethods from the interface, or if function signatures don't match,\nthen the type assertion can never succeed.\n\nThis check applies the same logic when asserting from one interface to\nanother. If both interface types contain the same method but with\ndifferent signatures, then the type assertion can never succeed,\neither.\n\nAvailable since\n    2020.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA5011\"",
							"Doc": "Possible nil pointer dereference\n\nA pointer is being dereferenced unconditionally, while\nalso being checked against nil in another place. This suggests that\nthe pointer may be nil and dereferencing it may panic. This is\ncommonly a result of improperly ordered code or missing return\nstatements. Consider the following examples:\n\n    func fn(x *int) {\n        fmt.Println(*x)\n\n        // This nil check is equally important for the previous dereference\n        if x != nil {\n            foo(*x)\n        }\n    }\n\n    func TestFoo(t *testing.T) {\n        x := compute()\n        if x == nil {\n            t.Errorf(\"nil pointer received\")\n        }\n\n        // t.Errorf does not abort the test, so if x is nil, the next line will panic.\n        foo(*x)\n    }\n\nStaticcheck tries to deduce which functions abort control flow.\nFor example, it is aware that a function will not continue\nexecution after a call to panic or log.Fatal. However, sometimes\nthis detection fails, in particular in the presence of\nconditionals. Consider the following example:\n\n    func Log(msg string, level int) {\n        fmt.Println(msg)\n        if level == levelFatal {\n            os.Exit(1)\n        }\n    }\n\n    func Fatal(msg string) {\n        Log(msg, levelFatal)\n    }\n\n    func fn(x *int) {\n        if x == nil {\n            Fatal(\"unexpected nil pointer\")\n        }\n        fmt.Println(*x)\n    }\n\nStaticcheck will flag the dereference of x, even though it is perfectly\nsafe. Staticcheck is not able to deduce that a call to\nFatal will exit the program. For the time being, the easiest\nworkaround is to modify the definition of Fatal like so:\n\n    func Fatal(msg string) {\n        Log(msg, levelFatal)\n        panic(\"unreachable\")\n    }\n\nWe also hard-code functions from common logging packages such as\nlogrus. Please file an issue if we're missing support for a\npopular package.\n\nAvailable since\n    2020.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA5012\"",
							"Doc": "Passing odd-sized slice to function expecting even size\n\nSome functions that take slices as parameters expect the slices to have an even number of elements. \nOften, these functions treat elements in a slice as pairs. \nFor example, strings.NewReplacer takes pairs of old and new strings, \nand calling it with an odd number of elements would be an error.\n\nAvailable since\n    2020.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA6000\"",
							"Doc": "Using regexp.Match or related in a loop, should use regexp.Compile\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA6001\"",
							"Doc": "Missing an optimization opportunity when indexing maps by byte slices\n\nMap keys must be comparable, which precludes the use of byte slices.\nThis usually leads to using string keys and converting byte slices to\nstrings.\n\nNormally, a conversion of a byte slice to a string needs to copy the data and\ncauses allocations. The compiler, however, recognizes m[string(b)] and\nuses the data of b directly, without copying it, because it knows that\nthe data can't change during the map lookup. This leads to the\ncounter-intuitive situation that\n\n    k := string(b)\n    println(m[k])\n    println(m[k])\n\nwill be less efficient than\n\n    println(m[string(b)])\n    println(m[string(b)])\n\nbecause the first version needs to copy and allocate, while the second\none does not.\n\nFor some history on this optimization, check out commit\nf5f5a8b6209f84961687d993b93ea0d397f5d5bf in the Go repository.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA6002\"",
							"Doc": "Storing non-pointer values in sync.Pool allocates memory\n\nA sync.Pool is used to avoid unnecessary allocations and reduce the\namount of work the garbage collector has to do.\n\nWhen passing a value that is not a pointer to a function that accepts\nan interface, the value needs to be placed on the heap, which means an\nadditional allocation. Slices are a common thing to put in sync.Pools,\nand they're structs with 3 fields (length, capacity, and a pointer to\nan array). In order to avoid the extra allocation, one should store a\npointer to the slice instead.\n\nSee the comments on https://go-review.googlesource.com/c/go/+/24371\nthat discuss this problem.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA6003\"",
							"Doc": "Converting a string to a slice of runes before ranging over it\n\nYou may want to loop over the runes in a string. Instead of converting\nthe string to a slice of runes and looping over that, you can loop\nover the string itself. That is,\n\n    for _, r := range s {}\n\nand\n\n    for _, r := range []rune(s) {}\n\nwill yield the same values. The first version, however, will be faster\nand avoid unnecessary memory allocations.\n\nDo note that if you are interested in the indices, ranging over a\nstring and over a slice of runes will yield different indices. The\nfirst one yields byte offsets, while the second one yields indices in\nthe slice of runes.\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA6005\"",
							"Doc": "Inefficient string comparison with strings.ToLower or strings.ToUpper\n\nConverting two strings to the same case and comparing them like so\n\n    if strings.ToLower(s1) == strings.ToLower(s2) {\n        ...\n    }\n\nis significantly more expensive than comparing them with\nstrings.EqualFold(s1, s2). This is due to memory usage as well as\ncomputational complexity.\n\nstrings.ToLower will have to allocate memory for the new strings, as\nwell as convert both strings fully, even if they differ on the very\nfirst byte. strings.EqualFold, on the other hand, compares the strings\none character at a time. It doesn't need to create two intermediate\nstrings and can return as soon as the first non-matching character has\nbeen found.\n\nFor a more in-depth explanation of this issue, see\nhttps://blog.digitalocean.com/how-to-efficiently-compare-strings-in-go/\n\nAvailable since\n    2019.2\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA6006\"",
							"Doc": "Using io.WriteString to write []byte\n\nUsing io.WriteString to write a slice of bytes, as in\n\n    io.WriteString(w, string(b))\n\nis both unnecessary and inefficient. Converting from []byte to string\nhas to allocate and copy the data, and we could simply use w.Write(b)\ninstead.\n\nAvailable since\n    2024.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA9001\"",
							"Doc": "Defers in range loops may not run when you expect them to\n\nAvailable since\n    2017.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA9002\"",
							"Doc": "Using a non-octal os.FileMode that looks like it was meant to be in octal.\n\nAvailable since\n    2017.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA9003\"",
							"Doc": "Empty body in an if or else branch\n\nAvailable since\n    2017.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA9004\"",
							"Doc": "Only the first constant has an explicit type\n\nIn a constant declaration such as the following:\n\n    const (\n        First byte = 1\n        Second     = 2\n    )\n\nthe constant Second does not have the same type as the constant First.\nThis construct shouldn't be confused with\n\n    const (\n        First byte = iota\n        Second\n    )\n\nwhere First and Second do indeed have the same type. The type is only\npassed on when no explicit value is assigned to the constant.\n\nWhen declaring enumerations with explicit values it is therefore\nimportant not to write\n\n    const (\n          EnumFirst EnumType = 1\n          EnumSecond         = 2\n          EnumThird          = 3\n    )\n\nThis discrepancy in types can cause various confusing behaviors and\nbugs.\n\n\nWrong type in variable declarations\n\nThe most obvious issue with such incorrect enumerations expresses\nitself as a compile error:\n\n    package pkg\n\n    const (\n        EnumFirst  uint8 = 1\n        EnumSecond       = 2\n    )\n\n    func fn(useFirst bool) {\n        x := EnumSecond\n        if useFirst {\n            x = EnumFirst\n        }\n    }\n\nfails to compile with\n\n    ./const.go:11:5: cannot use EnumFirst (type uint8) as type int in assignment\n\n\nLosing method sets\n\nA more subtle issue occurs with types that have methods and optional\ninterfaces. Consider the following:\n\n    package main\n\n    import \"fmt\"\n\n    type Enum int\n\n    func (e Enum) String() string {\n        return \"an enum\"\n    }\n\n    const (\n        EnumFirst  Enum = 1\n        EnumSecond      = 2\n    )\n\n    func main() {\n        fmt.Println(EnumFirst)\n        fmt.Println(EnumSecond)\n    }\n\nThis code will output\n\n    an enum\n    2\n\nas EnumSecond has no explicit type, and thus defaults to int.\n\nAvailable since\n    2019.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA9005\"",
							"Doc": "Trying to marshal a struct with no public fields nor custom marshaling\n\nThe encoding/json and encoding/xml packages only operate on exported\nfields in structs, not unexported ones. It is usually an error to try\nto (un)marshal structs that only consist of unexported fields.\n\nThis check will not flag calls involving types that define custom\nmarshaling behavior, e.g. via MarshalJSON methods. It will also not\nflag empty structs.\n\nAvailable since\n    2019.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA9006\"",
							"Doc": "Dubious bit shifting of a fixed size integer value\n\nBit shifting a value past its size will always clear the value.\n\nFor instance:\n\n    v := int8(42)\n    v \u003e\u003e= 8\n\nwill always result in 0.\n\nThis check flags bit shifting operations on fixed size integer values only.\nThat is, int, uint and uintptr are never flagged to avoid potential false\npositives in somewhat exotic but valid bit twiddling tricks:\n\n    // Clear any value above 32 bits if integers are more than 32 bits.\n    func f(i int) int {\n        v := i \u003e\u003e 32\n        v = v \u003c\u003c 32\n        return i-v\n    }\n\nAvailable since\n    2020.2\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"SA9007\"",
							"Doc": "Deleting a directory that shouldn't be deleted\n\nIt is virtually never correct to delete system directories such as\n/tmp or the user's home directory. However, it can be fairly easy to\ndo by mistake, for example by mistakenly using os.TempDir instead\nof ioutil.TempDir, or by forgetting to add a suffix to the result\nof os.UserHomeDir.\n\nWriting\n\n    d := os.TempDir()\n    defer os.RemoveAll(d)\n\nin your unit tests will have a devastating effect on the stability of your system.\n\nThis check flags attempts at deleting the following directories:\n\n- os.TempDir\n- os.UserCacheDir\n- os.UserConfigDir\n- os.UserHomeDir\n\nAvailable since\n    2022.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA9008\"",
							"Doc": "else branch of a type assertion is probably not reading the right value\n\nWhen declaring variables as part of an if statement (like in 'if\nfoo := ...; foo {'), the same variables will also be in the scope of\nthe else branch. This means that in the following example\n\n    if x, ok := x.(int); ok {\n        // ...\n    } else {\n        fmt.Printf(\"unexpected type %T\", x)\n    }\n\nx in the else branch will refer to the x from x, ok\n:=; it will not refer to the x that is being type-asserted. The\nresult of a failed type assertion is the zero value of the type that\nis being asserted to, so x in the else branch will always have the\nvalue 0 and the type int.\n\nAvailable since\n    2022.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"SA9009\"",
							"Doc": "Ineffectual Go compiler directive\n\nA potential Go compiler directive was found, but is ineffectual as it begins\nwith whitespace.\n\nAvailable since\n    2024.1\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"ST1000\"",
							"Doc": "Incorrect or missing package comment\n\nPackages must have a package comment that is formatted according to\nthe guidelines laid out in\nhttps://go.dev/wiki/CodeReviewComments#package-comments.\n\nAvailable since\n    2019.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1001\"",
							"Doc": "Dot imports are discouraged\n\nDot imports that aren't in external test packages are discouraged.\n\nThe dot_import_whitelist option can be used to whitelist certain\nimports.\n\nQuoting Go Code Review Comments:\n\n\u003e The import . form can be useful in tests that, due to circular\n\u003e dependencies, cannot be made part of the package being tested:\n\u003e \n\u003e     package foo_test\n\u003e \n\u003e     import (\n\u003e         \"bar/testutil\" // also imports \"foo\"\n\u003e         . \"foo\"\n\u003e     )\n\u003e \n\u003e In this case, the test file cannot be in package foo because it\n\u003e uses bar/testutil, which imports foo. So we use the import .\n\u003e form to let the file pretend to be part of package foo even though\n\u003e it is not. Except for this one case, do not use import . in your\n\u003e programs. It makes the programs much harder to read because it is\n\u003e unclear whether a name like Quux is a top-level identifier in the\n\u003e current package or in an imported package.\n\nAvailable since\n    2019.1\n\nOptions\n    dot_import_whitelist\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1003\"",
							"Doc": "Poorly chosen identifier\n\nIdentifiers, such as variable and package names, follow certain rules.\n\nSee the following links for details:\n\n- https://go.dev/doc/effective_go#package-names\n- https://go.dev/doc/effective_go#mixed-caps\n- https://go.dev/wiki/CodeReviewComments#initialisms\n- https://go.dev/wiki/CodeReviewComments#variable-names\n\nAvailable since\n    2019.1, non-default\n\nOptions\n    initialisms\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1005\"",
							"Doc": "Incorrectly formatted error string\n\nError strings follow a set of guidelines to ensure uniformity and good\ncomposability.\n\nQuoting Go Code Review Comments:\n\n\u003e Error strings should not be capitalized (unless beginning with\n\u003e proper nouns or acronyms) or end with punctuation, since they are\n\u003e usually printed following other context. That is, use\n\u003e fmt.Errorf(\"something bad\") not fmt.Errorf(\"Something bad\"), so\n\u003e that log.Printf(\"Reading %s: %v\", filename, err) formats without a\n\u003e spurious capital letter mid-message.\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1006\"",
							"Doc": "Poorly chosen receiver name\n\nQuoting Go Code Review Comments:\n\n\u003e The name of a method's receiver should be a reflection of its\n\u003e identity; often a one or two letter abbreviation of its type\n\u003e suffices (such as \"c\" or \"cl\" for \"Client\"). Don't use generic\n\u003e names such as \"me\", \"this\" or \"self\", identifiers typical of\n\u003e object-oriented languages that place more emphasis on methods as\n\u003e opposed to functions. The name need not be as descriptive as that\n\u003e of a method argument, as its role is obvious and serves no\n\u003e documentary purpose. It can be very short as it will appear on\n\u003e almost every line of every method of the type; familiarity admits\n\u003e brevity. Be consistent, too: if you call the receiver \"c\" in one\n\u003e method, don't call it \"cl\" in another.\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1008\"",
							"Doc": "A function's error value should be its last return value\n\nA function's error value should be its last return value.\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1011\"",
							"Doc": "Poorly chosen name for variable of type time.Duration\n\ntime.Duration values represent an amount of time, which is represented\nas a count of nanoseconds. An expression like 5 * time.Microsecond\nyields the value 5000. It is therefore not appropriate to suffix a\nvariable of type time.Duration with any time unit, such as Msec or\nMilli.\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1012\"",
							"Doc": "Poorly chosen name for error variable\n\nError variables that are part of an API should be called errFoo or\nErrFoo.\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1013\"",
							"Doc": "Should use constants for HTTP error codes, not magic numbers\n\nHTTP has a tremendous number of status codes. While some of those are\nwell known (200, 400, 404, 500), most of them are not. The net/http\npackage provides constants for all status codes that are part of the\nvarious specifications. It is recommended to use these constants\ninstead of hard-coding magic numbers, to vastly improve the\nreadability of your code.\n\nAvailable since\n    2019.1\n\nOptions\n    http_status_code_whitelist\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1015\"",
							"Doc": "A switch's default case should be the first or last case\n\nAvailable since\n    2019.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1016\"",
							"Doc": "Use consistent method receiver names\n\nAvailable since\n    2019.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1017\"",
							"Doc": "Don't use Yoda conditions\n\nYoda conditions are conditions of the kind 'if 42 == x', where the\nliteral is on the left side of the comparison. These are a common\nidiom in languages in which assignment is an expression, to avoid bugs\nof the kind 'if (x = 42)'. In Go, which doesn't allow for this kind of\nbug, we prefer the more idiomatic 'if x == 42'.\n\nAvailable since\n    2019.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1018\"",
							"Doc": "Avoid zero-width and control characters in string literals\n\nAvailable since\n    2019.2\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1019\"",
							"Doc": "Importing the same package multiple times\n\nGo allows importing the same package multiple times, as long as\ndifferent import aliases are being used. That is, the following\nbit of code is valid:\n\n    import (\n        \"fmt\"\n        fumpt \"fmt\"\n        format \"fmt\"\n        _ \"fmt\"\n    )\n\nHowever, this is very rarely done on purpose. Usually, it is a\nsign of code that got refactored, accidentally adding duplicate\nimport statements. It is also a rarely known feature, which may\ncontribute to confusion.\n\nDo note that sometimes, this feature may be used\nintentionally (see for example\nhttps://github.com/golang/go/commit/3409ce39bfd7584523b7a8c150a310cea92d879d)\n– if you want to allow this pattern in your code base, you're\nadvised to disable this check.\n\nAvailable since\n    2020.1\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1020\"",
							"Doc": "The documentation of an exported function should start with the function's name\n\nDoc comments work best as complete sentences, which\nallow a wide variety of automated presentations. The first sentence\nshould be a one-sentence summary that starts with the name being\ndeclared.\n\nIf every doc comment begins with the name of the item it describes,\nyou can use the doc subcommand of the go tool and run the output\nthrough grep.\n\nSee https://go.dev/doc/effective_go#commentary for more\ninformation on how to write good documentation.\n\nAvailable since\n    2020.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1021\"",
							"Doc": "The documentation of an exported type should start with type's name\n\nDoc comments work best as complete sentences, which\nallow a wide variety of automated presentations. The first sentence\nshould be a one-sentence summary that starts with the name being\ndeclared.\n\nIf every doc comment begins with the name of the item it describes,\nyou can use the doc subcommand of the go tool and run the output\nthrough grep.\n\nSee https://go.dev/doc/effective_go#commentary for more\ninformation on how to write good documentation.\n\nAvailable since\n    2020.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1022\"",
							"Doc": "The documentation of an exported variable or constant should start with variable's name\n\nDoc comments work best as complete sentences, which\nallow a wide variety of automated presentations. The first sentence\nshould be a one-sentence summary that starts with the name being\ndeclared.\n\nIf every doc comment begins with the name of the item it describes,\nyou can use the doc subcommand of the go tool and run the output\nthrough grep.\n\nSee https://go.dev/doc/effective_go#commentary for more\ninformation on how to write good documentation.\n\nAvailable since\n    2020.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ST1023\"",
							"Doc": "Redundant type in variable declaration\n\nAvailable since\n    2021.1, non-default\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"any\"",
							"Doc": "replace interface{} with any\n\nThe any analyzer suggests replacing uses of the empty interface type,\n`interface{}`, with the `any` alias, which was introduced in Go 1.18.\nThis is a purely stylistic change that makes code more readable.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"appendclipped\"",
							"Doc": "simplify append chains using slices.Concat\n\nThe appendclipped analyzer suggests replacing chains of append calls with a\nsingle call to slices.Concat, which was added in Go 1.21. For example,\nappend(append(s, s1...), s2...) would be simplified to slices.Concat(s, s1, s2).\n\nIn the simple case of appending to a newly allocated slice, such as\nappend([]T(nil), s...), the analyzer suggests the more concise slices.Clone(s).\nFor byte slices, it will prefer bytes.Clone if the \"bytes\" package is\nalready imported.\n\nThis fix is only applied when the base of the append tower is a\n\"clipped\" slice, meaning its length and capacity are equal (e.g.\nx[:0:0] or []T{}). This is to avoid changing program behavior by\neliminating intended side effects on the base slice's underlying\narray.\n\nThis analyzer is currently disabled by default as the\ntransformation does not preserve the nilness of the base slice in\nall cases; see https://go.dev/issue/73557.",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"appends\"",
							"Doc": "check for missing values after append\n\nThis checker reports calls to append that pass\nno values to be appended to the slice.\n\n\ts := []string{\"a\", \"b\", \"c\"}\n\t_ = append(s)\n\nSuch calls are always no-ops and often indicate an\nunderlying mistake.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"asmdecl\"",
							"Doc": "report mismatches between assembly files and Go declarations",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"assign\"",
							"Doc": "check for useless assignments\n\nThis checker reports assignments of the form x = x or a[i] = a[i].\nThese are almost always useless, and even when they aren't they are\nusually a mistake.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"atomic\"",
							"Doc": "check for common mistakes using the sync/atomic package\n\nThe atomic checker looks for assignment statements of the form:\n\n\tx = atomic.AddUint64(\u0026x, 1)\n\nwhich are not atomic.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"atomicalign\"",
							"Doc": "check for non-64-bits-aligned arguments to sync/atomic functions",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"bloop\"",
							"Doc": "replace for-range over b.N with b.Loop\n\nThe bloop analyzer suggests replacing benchmark loops of the form\n`for i := 0; i \u003c b.N; i++` or `for range b.N` with the more modern\n`for b.Loop()`, which was added in Go 1.24.\n\nThis change makes benchmark code more readable and also removes the need for\nmanual timer control, so any preceding calls to b.StartTimer, b.StopTimer,\nor b.ResetTimer within the same function will also be removed.\n\nCaveats: The b.Loop() method is designed to prevent the compiler from\noptimizing away the benchmark loop, which can occasionally result in\nslower execution due to increased allocations in some specific cases.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"bools\"",
							"Doc": "check for common mistakes involving boolean operators",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"buildtag\"",
							"Doc": "check //go:build and // +build directives",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"cgocall\"",
							"Doc": "detect some violations of the cgo pointer passing rules\n\nCheck for invalid cgo pointer passing.\nThis looks for code that uses cgo to call C code passing values\nwhose types are almost always invalid according to the cgo pointer\nsharing rules.\nSpecifically, it warns about attempts to pass a Go chan, map, func,\nor slice to C, either directly, or via a pointer, array, or struct.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"composites\"",
							"Doc": "check for unkeyed composite literals\n\nThis analyzer reports a diagnostic for composite literals of struct\ntypes imported from another package that do not use the field-keyed\nsyntax. Such literals are fragile because the addition of a new field\n(even if unexported) to the struct will cause compilation to fail.\n\nAs an example,\n\n\terr = \u0026net.DNSConfigError{err}\n\nshould be replaced by:\n\n\terr = \u0026net.DNSConfigError{Err: err}\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"copylocks\"",
							"Doc": "check for locks erroneously passed by value\n\nInadvertently copying a value containing a lock, such as sync.Mutex or\nsync.WaitGroup, may cause both copies to malfunction. Generally such\nvalues should be referred to through a pointer.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"deepequalerrors\"",
							"Doc": "check for calls of reflect.DeepEqual on error values\n\nThe deepequalerrors checker looks for calls of the form:\n\n    reflect.DeepEqual(err1, err2)\n\nwhere err1 and err2 are errors. Using reflect.DeepEqual to compare\nerrors is discouraged.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"defers\"",
							"Doc": "report common mistakes in defer statements\n\nThe defers analyzer reports a diagnostic when a defer statement would\nresult in a non-deferred call to time.Since, as experience has shown\nthat this is nearly always a mistake.\n\nFor example:\n\n\tstart := time.Now()\n\t...\n\tdefer recordLatency(time.Since(start)) // error: call to time.Since is not deferred\n\nThe correct code is:\n\n\tdefer func() { recordLatency(time.Since(start)) }()",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"deprecated\"",
							"Doc": "check for use of deprecated identifiers\n\nThe deprecated analyzer looks for deprecated symbols and package\nimports.\n\nSee https://go.dev/wiki/Deprecated to learn about Go's convention\nfor documenting and signaling deprecated identifiers.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"directive\"",
							"Doc": "check Go toolchain directives such as //go:debug\n\nThis analyzer checks for problems with known Go toolchain directives\nin all Go source files in a package directory, even those excluded by\n//go:build constraints, and all non-Go source files too.\n\nFor //go:debug (see https://go.dev/doc/godebug), the analyzer checks\nthat the directives are placed only in Go source files, only above the\npackage comment, and only in package main or *_test.go files.\n\nSupport for other known directives may be added in the future.\n\nThis analyzer does not check //go:build, which is handled by the\nbuildtag analyzer.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"embed\"",
							"Doc": "check //go:embed directive usage\n\nThis analyzer checks that the embed package is imported if //go:embed\ndirectives are present, providing a suggested fix to add the import if\nit is missing.\n\nThis analyzer also checks that //go:embed directives precede the\ndeclaration of a single variable.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"errorsas\"",
							"Doc": "report passing non-pointer or non-error values to errors.As\n\nThe errorsas analyzer reports calls to errors.As where the type\nof the second argument is not a pointer to a type implementing error.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"errorsastype\"",
							"Doc": "replace errors.As with errors.AsType[T]\n\nThis analyzer suggests fixes to simplify uses of [errors.As] of\nthis form:\n\n\tvar myerr *MyErr\n\tif errors.As(err, \u0026myerr) {\n\t\thandle(myerr)\n\t}\n\nby using the less error-prone generic [errors.AsType] function,\nintroduced in Go 1.26:\n\n\tif myerr, ok := errors.AsType[*MyErr](err); ok {\n\t\thandle(myerr)\n\t}\n\nThe fix is only offered if the var declaration has the form shown and\nthere are no uses of myerr outside the if statement.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"fillreturns\"",
							"Doc": "suggest fixes for errors due to an incorrect number of return values\n\nThis checker provides suggested fixes for type errors of the\ntype \"wrong number of return values (want %d, got %d)\". For example:\n\n\tfunc m() (int, string, *bool, error) {\n\t\treturn\n\t}\n\nwill turn into\n\n\tfunc m() (int, string, *bool, error) {\n\t\treturn 0, \"\", nil, nil\n\t}\n\nThis functionality is similar to https://github.com/sqs/goreturns.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"fmtappendf\"",
							"Doc": "replace []byte(fmt.Sprintf) with fmt.Appendf\n\nThe fmtappendf analyzer suggests replacing `[]byte(fmt.Sprintf(...))` with\n`fmt.Appendf(nil, ...)`. This avoids the intermediate allocation of a string\nby Sprintf, making the code more efficient. The suggestion also applies to\nfmt.Sprint and fmt.Sprintln.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"forvar\"",
							"Doc": "remove redundant re-declaration of loop variables\n\nThe forvar analyzer removes unnecessary shadowing of loop variables.\nBefore Go 1.22, it was common to write `for _, x := range s { x := x ... }`\nto create a fresh variable for each iteration. Go 1.22 changed the semantics\nof `for` loops, making this pattern redundant. This analyzer removes the\nunnecessary `x := x` statement.\n\nThis fix only applies to `range` loops.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"framepointer\"",
							"Doc": "report assembly that clobbers the frame pointer before saving it",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"hostport\"",
							"Doc": "check format of addresses passed to net.Dial\n\nThis analyzer flags code that produce network address strings using\nfmt.Sprintf, as in this example:\n\n    addr := fmt.Sprintf(\"%s:%d\", host, 12345) // \"will not work with IPv6\"\n    ...\n    conn, err := net.Dial(\"tcp\", addr)       // \"when passed to dial here\"\n\nThe analyzer suggests a fix to use the correct approach, a call to\nnet.JoinHostPort:\n\n    addr := net.JoinHostPort(host, \"12345\")\n    ...\n    conn, err := net.Dial(\"tcp\", addr)\n\nA similar diagnostic and fix are produced for a format string of \"%s:%s\".\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"httpresponse\"",
							"Doc": "check for mistakes using HTTP responses\n\nA common mistake when using the net/http package is to defer a function\ncall to close the http.Response Body before checking the error that\ndetermines whether the response is valid:\n\n\tresp, err := http.Head(url)\n\tdefer resp.Body.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// (defer statement belongs here)\n\nThis checker helps uncover latent nil dereference bugs by reporting a\ndiagnostic for such mistakes.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"ifaceassert\"",
							"Doc": "detect impossible interface-to-interface type assertions\n\nThis checker flags type assertions v.(T) and corresponding type-switch cases\nin which the static type V of v is an interface that cannot possibly implement\nthe target interface T. This occurs when V and T contain methods with the same\nname but different signatures. Example:\n\n\tvar v interface {\n\t\tRead()\n\t}\n\t_ = v.(io.Reader)\n\nThe Read method in v has a different signature than the Read method in\nio.Reader, so this assertion cannot succeed.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"infertypeargs\"",
							"Doc": "check for unnecessary type arguments in call expressions\n\nExplicit type arguments may be omitted from call expressions if they can be\ninferred from function arguments, or from other type arguments:\n\n\tfunc f[T any](T) {}\n\t\n\tfunc _() {\n\t\tf[string](\"foo\") // string could be inferred\n\t}\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"inline\"",
							"Doc": "apply fixes based on 'go:fix inline' comment directives\n\nThe inline analyzer inlines functions and constants that are marked for inlining.\n\n## Functions\n\nGiven a function that is marked for inlining, like this one:\n\n\t//go:fix inline\n\tfunc Square(x int) int { return Pow(x, 2) }\n\nthis analyzer will recommend that calls to the function elsewhere, in the same\nor other packages, should be inlined.\n\nInlining can be used to move off of a deprecated function:\n\n\t// Deprecated: prefer Pow(x, 2).\n\t//go:fix inline\n\tfunc Square(x int) int { return Pow(x, 2) }\n\nIt can also be used to move off of an obsolete package,\nas when the import path has changed or a higher major version is available:\n\n\tpackage pkg\n\n\timport pkg2 \"pkg/v2\"\n\n\t//go:fix inline\n\tfunc F() { pkg2.F(nil) }\n\nReplacing a call pkg.F() by pkg2.F(nil) can have no effect on the program,\nso this mechanism provides a low-risk way to update large numbers of calls.\nWe recommend, where possible, expressing the old API in terms of the new one\nto enable automatic migration.\n\nThe inliner takes care to avoid behavior changes, even subtle ones,\nsuch as changes to the order in which argument expressions are\nevaluated. When it cannot safely eliminate all parameter variables,\nit may introduce a \"binding declaration\" of the form\n\n\tvar params = args\n\nto evaluate argument expressions in the correct order and bind them to\nparameter variables. Since the resulting code transformation may be\nstylistically suboptimal, such inlinings may be disabled by specifying\nthe -inline.allow_binding_decl=false flag to the analyzer driver.\n\n(In cases where it is not safe to \"reduce\" a call—that is, to replace\na call f(x) by the body of function f, suitably substituted—the\ninliner machinery is capable of replacing f by a function literal,\nfunc(){...}(). However, the inline analyzer discards all such\n\"literalizations\" unconditionally, again on grounds of style.)\n\n## Constants\n\nGiven a constant that is marked for inlining, like this one:\n\n\t//go:fix inline\n\tconst Ptr = Pointer\n\nthis analyzer will recommend that uses of Ptr should be replaced with Pointer.\n\nAs with functions, inlining can be used to replace deprecated constants and\nconstants in obsolete packages.\n\nA constant definition can be marked for inlining only if it refers to another\nnamed constant.\n\nThe \"//go:fix inline\" comment must appear before a single const declaration on its own,\nas above; before a const declaration that is part of a group, as in this case:\n\n\tconst (\n\t   C = 1\n\t   //go:fix inline\n\t   Ptr = Pointer\n\t)\n\nor before a group, applying to every constant in the group:\n\n\t//go:fix inline\n\tconst (\n\t\tPtr = Pointer\n\t    Val = Value\n\t)\n\nThe proposal https://go.dev/issue/32816 introduces the \"//go:fix inline\" directives.\n\nYou can use this command to apply inline fixes en masse:\n\n\t$ go run golang.org/x/tools/go/analysis/passes/inline/cmd/inline@latest -fix ./...",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"loopclosure\"",
							"Doc": "check references to loop variables from within nested functions\n\nThis analyzer reports places where a function literal references the\niteration variable of an enclosing loop, and the loop calls the function\nin such a way (e.g. with go or defer) that it may outlive the loop\niteration and possibly observe the wrong value of the variable.\n\nNote: An iteration variable can only outlive a loop iteration in Go versions \u003c=1.21.\nIn Go 1.22 and later, the loop variable lifetimes changed to create a new\niteration variable per loop iteration. (See go.dev/issue/60078.)\n\nIn this example, all the deferred functions run after the loop has\ncompleted, so all observe the final value of v [\u003cgo1.22].\n\n\tfor _, v := range list {\n\t    defer func() {\n\t        use(v) // incorrect\n\t    }()\n\t}\n\nOne fix is to create a new variable for each iteration of the loop:\n\n\tfor _, v := range list {\n\t    v := v // new var per iteration\n\t    defer func() {\n\t        use(v) // ok\n\t    }()\n\t}\n\nAfter Go version 1.22, the previous two for loops are equivalent\nand both are correct.\n\nThe next example uses a go statement and has a similar problem [\u003cgo1.22].\nIn addition, it has a data race because the loop updates v\nconcurrent with the goroutines accessing it.\n\n\tfor _, v := range elem {\n\t    go func() {\n\t        use(v)  // incorrect, and a data race\n\t    }()\n\t}\n\nA fix is the same as before. The checker also reports problems\nin goroutines started by golang.org/x/sync/errgroup.Group.\nA hard-to-spot variant of this form is common in parallel tests:\n\n\tfunc Test(t *testing.T) {\n\t    for _, test := range tests {\n\t        t.Run(test.name, func(t *testing.T) {\n\t            t.Parallel()\n\t            use(test) // incorrect, and a data race\n\t        })\n\t    }\n\t}\n\nThe t.Parallel() call causes the rest of the function to execute\nconcurrent with the loop [\u003cgo1.22].\n\nThe analyzer reports references only in the last statement,\nas it is not deep enough to understand the effects of subsequent\nstatements that might render the reference benign.\n(\"Last statement\" is defined recursively in compound\nstatements such as if, switch, and select.)\n\nSee: https://golang.org/doc/go_faq.html#closures_and_goroutines",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"lostcancel\"",
							"Doc": "check cancel func returned by context.WithCancel is called\n\nThe cancellation function returned by context.WithCancel, WithTimeout,\nWithDeadline and variants such as WithCancelCause must be called,\nor the new context will remain live until its parent context is cancelled.\n(The background context is never cancelled.)",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"maprange\"",
							"Doc": "checks for unnecessary calls to maps.Keys and maps.Values in range statements\n\nConsider a loop written like this:\n\n\tfor val := range maps.Values(m) {\n\t\tfmt.Println(val)\n\t}\n\nThis should instead be written without the call to maps.Values:\n\n\tfor _, val := range m {\n\t\tfmt.Println(val)\n\t}\n\ngolang.org/x/exp/maps returns slices for Keys/Values instead of iterators,\nbut unnecessary calls should similarly be removed:\n\n\tfor _, key := range maps.Keys(m) {\n\t\tfmt.Println(key)\n\t}\n\nshould be rewritten as:\n\n\tfor key := range m {\n\t\tfmt.Println(key)\n\t}",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"mapsloop\"",
							"Doc": "replace explicit loops over maps with calls to maps package\n\nThe mapsloop analyzer replaces loops of the form\n\n\tfor k, v := range x { m[k] = v }\n\nwith a single call to a function from the `maps` package, added in Go 1.23.\nDepending on the context, this could be `maps.Copy`, `maps.Insert`,\n`maps.Clone`, or `maps.Collect`.\n\nThe transformation to `maps.Clone` is applied conservatively, as it\npreserves the nilness of the source map, which may be a subtle change in\nbehavior if the original code did not handle a nil map in the same way.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"minmax\"",
							"Doc": "replace if/else statements with calls to min or max\n\nThe minmax analyzer simplifies conditional assignments by suggesting the use\nof the built-in `min` and `max` functions, introduced in Go 1.21. For example,\n\n\tif a \u003c b { x = a } else { x = b }\n\nis replaced by\n\n\tx = min(a, b).\n\nThis analyzer avoids making suggestions for floating-point types,\nas the behavior of `min` and `max` with NaN values can differ from\nthe original if/else statement.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"newexpr\"",
							"Doc": "simplify code by using go1.26's new(expr)\n\nThis analyzer finds declarations of functions of this form:\n\n\tfunc varOf(x int) *int { return \u0026x }\n\nand suggests a fix to turn them into inlinable wrappers around\ngo1.26's built-in new(expr) function:\n\n\t//go:fix inline\n\tfunc varOf(x int) *int { return new(x) }\n\n(The directive comment causes the 'inline' analyzer to suggest\nthat calls to such functions are inlined.)\n\nIn addition, this analyzer suggests a fix for each call\nto one of the functions before it is transformed, so that\n\n\tuse(varOf(123))\n\nis replaced by:\n\n\tuse(new(123))\n\nWrapper functions such as varOf are common when working with Go\nserialization packages such as for JSON or protobuf, where pointers\nare often used to express optionality.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"nilfunc\"",
							"Doc": "check for useless comparisons between functions and nil\n\nA useless comparison is one like f == nil as opposed to f() == nil.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"nilness\"",
							"Doc": "check for redundant or impossible nil comparisons\n\nThe nilness checker inspects the control-flow graph of each function in\na package and reports nil pointer dereferences, degenerate nil\npointers, and panics with nil values. A degenerate comparison is of the form\nx==nil or x!=nil where x is statically known to be nil or non-nil. These are\noften a mistake, especially in control flow related to errors. Panics with nil\nvalues are checked because they are not detectable by\n\n\tif r := recover(); r != nil {\n\nThis check reports conditions such as:\n\n\tif f == nil { // impossible condition (f is a function)\n\t}\n\nand:\n\n\tp := \u0026v\n\t...\n\tif p != nil { // tautological condition\n\t}\n\nand:\n\n\tif p == nil {\n\t\tprint(*p) // nil dereference\n\t}\n\nand:\n\n\tif p == nil {\n\t\tpanic(p)\n\t}\n\nSometimes the control flow may be quite complex, making bugs hard\nto spot. In the example below, the err.Error expression is\nguaranteed to panic because, after the first return, err must be\nnil. The intervening loop is just a distraction.\n\n\t...\n\terr := g.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpartialSuccess := false\n\tfor _, err := range errs {\n\t\tif err == nil {\n\t\t\tpartialSuccess = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif partialSuccess {\n\t\treportStatus(StatusMessage{\n\t\t\tCode:   code.ERROR,\n\t\t\tDetail: err.Error(), // \"nil dereference in dynamic method call\"\n\t\t})\n\t\treturn nil\n\t}\n\n...",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"nonewvars\"",
							"Doc": "suggested fixes for \"no new vars on left side of :=\"\n\nThis checker provides suggested fixes for type errors of the\ntype \"no new vars on left side of :=\". For example:\n\n\tz := 1\n\tz := 2\n\nwill turn into\n\n\tz := 1\n\tz = 2",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"noresultvalues\"",
							"Doc": "suggested fixes for unexpected return values\n\nThis checker provides suggested fixes for type errors of the\ntype \"no result values expected\" or \"too many return values\".\nFor example:\n\n\tfunc z() { return nil }\n\nwill turn into\n\n\tfunc z() { return }",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"omitzero\"",
							"Doc": "suggest replacing omitempty with omitzero for struct fields\n\nThe omitzero analyzer identifies uses of the `omitempty` JSON struct\ntag on fields that are themselves structs. For struct-typed fields,\nthe `omitempty` tag has no effect on the behavior of json.Marshal and\njson.Unmarshal. The analyzer offers two suggestions: either remove the\ntag, or replace it with `omitzero` (added in Go 1.24), which correctly\nomits the field if the struct value is zero.\n\nHowever, some other serialization packages (notably kubebuilder, see\nhttps://book.kubebuilder.io/reference/markers.html) may have their own\ninterpretation of the `json:\",omitzero\"` tag, so removing it may affect\nprogram behavior. For this reason, the omitzero modernizer will not\nmake changes in any package that contains +kubebuilder annotations.\n\nReplacing `omitempty` with `omitzero` is a change in behavior. The\noriginal code would always encode the struct field, whereas the\nmodified code will omit it if it is a zero-value.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"plusbuild\"",
							"Doc": "remove obsolete //+build comments\n\nThe plusbuild analyzer suggests a fix to remove obsolete build tags\nof the form:\n\n\t//+build linux,amd64\n\nin files that also contain a Go 1.18-style tag such as:\n\n\t//go:build linux \u0026\u0026 amd64\n\n(It does not check that the old and new tags are consistent;\nthat is the job of the 'buildtag' analyzer in the vet suite.)",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"printf\"",
							"Doc": "check consistency of Printf format strings and arguments\n\nThe check applies to calls of the formatting functions such as\n[fmt.Printf] and [fmt.Sprintf], as well as any detected wrappers of\nthose functions such as [log.Printf]. It reports a variety of\nmistakes such as syntax errors in the format string and mismatches\n(of number and type) between the verbs and their arguments.\n\nSee the documentation of the fmt package for the complete set of\nformat operators and their operand types.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"rangeint\"",
							"Doc": "replace 3-clause for loops with for-range over integers\n\nThe rangeint analyzer suggests replacing traditional for loops such\nas\n\n\tfor i := 0; i \u003c n; i++ { ... }\n\nwith the more idiomatic Go 1.22 style:\n\n\tfor i := range n { ... }\n\nThis transformation is applied only if (a) the loop variable is not\nmodified within the loop body and (b) the loop's limit expression\nis not modified within the loop, as `for range` evaluates its\noperand only once.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"recursiveiter\"",
							"Doc": "check for inefficient recursive iterators\n\nThis analyzer reports when a function that returns an iterator\n(iter.Seq or iter.Seq2) calls itself as the operand of a range\nstatement, as this is inefficient.\n\nWhen implementing an iterator (e.g. iter.Seq[T]) for a recursive\ndata type such as a tree or linked list, it is tempting to\nrecursively range over the iterator for each child element.\n\nHere's an example of a naive iterator over a binary tree:\n\n\ttype tree struct {\n\t\tvalue       int\n\t\tleft, right *tree\n\t}\n\n\tfunc (t *tree) All() iter.Seq[int] {\n\t\treturn func(yield func(int) bool) {\n\t\t\tif t != nil {\n\t\t\t\tfor elem := range t.left.All() { // \"inefficient recursive iterator\"\n\t\t\t\t\tif !yield(elem) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !yield(t.value) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor elem := range t.right.All() { // \"inefficient recursive iterator\"\n\t\t\t\t\tif !yield(elem) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nThough it correctly enumerates the elements of the tree, it hides a\nsignificant performance problem--two, in fact. Consider a balanced\ntree of N nodes. Iterating the root node will cause All to be\ncalled once on every node of the tree. This results in a chain of\nnested active range-over-func statements when yield(t.value) is\ncalled on a leaf node.\n\nThe first performance problem is that each range-over-func\nstatement must typically heap-allocate a variable, so iteration of\nthe tree allocates as many variables as there are elements in the\ntree, for a total of O(N) allocations, all unnecessary.\n\nThe second problem is that each call to yield for a leaf of the\ntree causes each of the enclosing range loops to receive a value,\nwhich they then immediately pass on to their respective yield\nfunction. This results in a chain of log(N) dynamic yield calls per\nelement, a total of O(N*log N) dynamic calls overall, when only\nO(N) are necessary.\n\nA better implementation strategy for recursive iterators is to\nfirst define the \"every\" operator for your recursive data type,\nwhere every(f) reports whether an arbitrary predicate f(x) is true\nfor every element x in the data type. For our tree, the every\nfunction would be:\n\n\tfunc (t *tree) every(f func(int) bool) bool {\n\t\treturn t == nil ||\n\t\t\tt.left.every(f) \u0026\u0026 f(t.value) \u0026\u0026 t.right.every(f)\n\t}\n\nFor example, this use of the every operator prints whether every\nelement in the tree is an even number:\n\n\teven := func(x int) bool { return x\u00261 == 0 }\n\tprintln(t.every(even))\n\nThen the iterator can be simply expressed as a trivial wrapper\naround the every operator:\n\n\tfunc (t *tree) All() iter.Seq[int] {\n\t\treturn func(yield func(int) bool) {\n\t\t\t_ = t.every(yield)\n\t\t}\n\t}\n\nIn effect, tree.All computes whether yield returns true for each\nelement, short-circuiting if it ever returns false, then discards\nthe final boolean result.\n\nThis has much better performance characteristics: it makes one\ndynamic call per element of the tree, and it doesn't heap-allocate\nanything. It is also clearer.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"reflecttypefor\"",
							"Doc": "replace reflect.TypeOf(x) with TypeFor[T]()\n\nThis analyzer suggests fixes to replace uses of reflect.TypeOf(x) with\nreflect.TypeFor, introduced in go1.22, when the desired runtime type\nis known at compile time, for example:\n\n\treflect.TypeOf(uint32(0))        -\u003e reflect.TypeFor[uint32]()\n\treflect.TypeOf((*ast.File)(nil)) -\u003e reflect.TypeFor[*ast.File]()\n\nIt also offers a fix to simplify the construction below, which uses\nreflect.TypeOf to return the runtime type for an interface type,\n\n\treflect.TypeOf((*io.Reader)(nil)).Elem()\n\nto:\n\n\treflect.TypeFor[io.Reader]()\n\nNo fix is offered in cases when the runtime type is dynamic, such as:\n\n\tvar r io.Reader = ...\n\treflect.TypeOf(r)\n\nor when the operand has potential side effects.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"shadow\"",
							"Doc": "check for possible unintended shadowing of variables\n\nThis analyzer check for shadowed variables.\nA shadowed variable is a variable declared in an inner scope\nwith the same name and type as a variable in an outer scope,\nand where the outer variable is mentioned after the inner one\nis declared.\n\n(This definition can be refined; the module generates too many\nfalse positives and is not yet enabled by default.)\n\nFor example:\n\n\tfunc BadRead(f *os.File, buf []byte) error {\n\t\tvar err error\n\t\tfor {\n\t\t\tn, err := f.Read(buf) // shadows the function variable 'err'\n\t\t\tif err != nil {\n\t\t\t\tbreak // causes return of wrong value\n\t\t\t}\n\t\t\tfoo(buf)\n\t\t}\n\t\treturn err\n\t}",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"shift\"",
							"Doc": "check for shifts that equal or exceed the width of the integer",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"sigchanyzer\"",
							"Doc": "check for unbuffered channel of os.Signal\n\nThis checker reports call expression of the form\n\n\tsignal.Notify(c \u003c-chan os.Signal, sig ...os.Signal),\n\nwhere c is an unbuffered channel, which can be at risk of missing the signal.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"simplifycompositelit\"",
							"Doc": "check for composite literal simplifications\n\nAn array, slice, or map composite literal of the form:\n\n\t[]T{T{}, T{}}\n\nwill be simplified to:\n\n\t[]T{{}, {}}\n\nThis is one of the simplifications that \"gofmt -s\" applies.\n\nThis analyzer ignores generated code.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"simplifyrange\"",
							"Doc": "check for range statement simplifications\n\nA range of the form:\n\n\tfor x, _ = range v {...}\n\nwill be simplified to:\n\n\tfor x = range v {...}\n\nA range of the form:\n\n\tfor _ = range v {...}\n\nwill be simplified to:\n\n\tfor range v {...}\n\nThis is one of the simplifications that \"gofmt -s\" applies.\n\nThis analyzer ignores generated code.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"simplifyslice\"",
							"Doc": "check for slice simplifications\n\nA slice expression of the form:\n\n\ts[a:len(s)]\n\nwill be simplified to:\n\n\ts[a:]\n\nThis is one of the simplifications that \"gofmt -s\" applies.\n\nThis analyzer ignores generated code.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"slicescontains\"",
							"Doc": "replace loops with slices.Contains or slices.ContainsFunc\n\nThe slicescontains analyzer simplifies loops that check for the existence of\nan element in a slice. It replaces them with calls to `slices.Contains` or\n`slices.ContainsFunc`, which were added in Go 1.21.\n\nIf the expression for the target element has side effects, this\ntransformation will cause those effects to occur only once, not\nonce per tested slice element.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"slicesdelete\"",
							"Doc": "replace append-based slice deletion with slices.Delete\n\nThe slicesdelete analyzer suggests replacing the idiom\n\n\ts = append(s[:i], s[j:]...)\n\nwith the more explicit\n\n\ts = slices.Delete(s, i, j)\n\nintroduced in Go 1.21.\n\nThis analyzer is disabled by default. The `slices.Delete` function\nzeros the elements between the new length and the old length of the\nslice to prevent memory leaks, which is a subtle difference in\nbehavior compared to the append-based idiom; see https://go.dev/issue/73686.",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"slicessort\"",
							"Doc": "replace sort.Slice with slices.Sort for basic types\n\nThe slicessort analyzer simplifies sorting slices of basic ordered\ntypes. It replaces\n\n\tsort.Slice(s, func(i, j int) bool { return s[i] \u003c s[j] })\n\nwith the simpler `slices.Sort(s)`, which was added in Go 1.21.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"slog\"",
							"Doc": "check for invalid structured logging calls\n\nThe slog checker looks for calls to functions from the log/slog\npackage that take alternating key-value pairs. It reports calls\nwhere an argument in a key position is neither a string nor a\nslog.Attr, and where a final key is missing its value.\nFor example,it would report\n\n\tslog.Warn(\"message\", 11, \"k\") // slog.Warn arg \"11\" should be a string or a slog.Attr\n\nand\n\n\tslog.Info(\"message\", \"k1\", v1, \"k2\") // call to slog.Info missing a final value",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"sortslice\"",
							"Doc": "check the argument type of sort.Slice\n\nsort.Slice requires an argument of a slice type. Check that\nthe interface{} value passed to sort.Slice is actually a slice.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stditerators\"",
							"Doc": "use iterators instead of Len/At-style APIs\n\nThis analyzer suggests a fix to replace each loop of the form:\n\n\tfor i := 0; i \u003c x.Len(); i++ {\n\t\tuse(x.At(i))\n\t}\n\nor its \"for elem := range x.Len()\" equivalent by a range loop over an\niterator offered by the same data type:\n\n\tfor elem := range x.All() {\n\t\tuse(x.At(i)\n\t}\n\nwhere x is one of various well-known types in the standard library.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stdmethods\"",
							"Doc": "check signature of methods of well-known interfaces\n\nSometimes a type may be intended to satisfy an interface but may fail to\ndo so because of a mistake in its method signature.\nFor example, the result of this WriteTo method should be (int64, error),\nnot error, to satisfy io.WriterTo:\n\n\ttype myWriterTo struct{...}\n\tfunc (myWriterTo) WriteTo(w io.Writer) error { ... }\n\nThis check ensures that each method whose name matches one of several\nwell-known interface methods from the standard library has the correct\nsignature for that interface.\n\nChecked method names include:\n\n\tFormat GobEncode GobDecode MarshalJSON MarshalXML\n\tPeek ReadByte ReadFrom ReadRune Scan Seek\n\tUnmarshalJSON UnreadByte UnreadRune WriteByte\n\tWriteTo",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stdversion\"",
							"Doc": "report uses of too-new standard library symbols\n\nThe stdversion analyzer reports references to symbols in the standard\nlibrary that were introduced by a Go release higher than the one in\nforce in the referring file. (Recall that the file's Go version is\ndefined by the 'go' directive its module's go.mod file, or by a\n\"//go:build go1.X\" build tag at the top of the file.)\n\nThe analyzer does not report a diagnostic for a reference to a \"too\nnew\" field or method of a type that is itself \"too new\", as this may\nhave false positives, for example if fields or methods are accessed\nthrough a type alias that is guarded by a Go version constraint.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stringintconv\"",
							"Doc": "check for string(int) conversions\n\nThis checker flags conversions of the form string(x) where x is an integer\n(but not byte or rune) type. Such conversions are discouraged because they\nreturn the UTF-8 representation of the Unicode code point x, and not a decimal\nstring representation of x as one might expect. Furthermore, if x denotes an\ninvalid code point, the conversion cannot be statically rejected.\n\nFor conversions that intend on using the code point, consider replacing them\nwith string(rune(x)). Otherwise, strconv.Itoa and its equivalents return the\nstring representation of the value in the desired base.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stringsbuilder\"",
							"Doc": "replace += with strings.Builder\n\nThis analyzer replaces repeated string += string concatenation\noperations with calls to Go 1.10's strings.Builder.\n\nFor example:\n\n\tvar s = \"[\"\n\tfor x := range seq {\n\t\ts += x\n\t\ts += \".\"\n\t}\n\ts += \"]\"\n\tuse(s)\n\nis replaced by:\n\n\tvar s strings.Builder\n\ts.WriteString(\"[\")\n\tfor x := range seq {\n\t\ts.WriteString(x)\n\t\ts.WriteString(\".\")\n\t}\n\ts.WriteString(\"]\")\n\tuse(s.String())\n\nThis avoids quadratic memory allocation and improves performance.\n\nThe analyzer requires that all references to s except the final one\nare += operations. To avoid warning about trivial cases, at least one\nmust appear within a loop. The variable s must be a local\nvariable, not a global or parameter.\n\nThe sole use of the finished string must be the last reference to the\nvariable s. (It may appear within an intervening loop or function literal,\nsince even s.String() is called repeatedly, it does not allocate memory.)",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stringscut\"",
							"Doc": "replace strings.Index etc. with strings.Cut\n\nThis analyzer replaces certain patterns of use of [strings.Index] and string slicing by [strings.Cut], added in go1.18.\n\nFor example:\n\n\tidx := strings.Index(s, substr)\n\tif idx \u003e= 0 {\n\t    return s[:idx]\n\t}\n\nis replaced by:\n\n\tbefore, _, ok := strings.Cut(s, substr)\n\tif ok {\n\t    return before\n\t}\n\nAnd:\n\n\tidx := strings.Index(s, substr)\n\tif idx \u003e= 0 {\n\t    return\n\t}\n\nis replaced by:\n\n\tfound := strings.Contains(s, substr)\n\tif found {\n\t    return\n\t}\n\nIt also handles variants using [strings.IndexByte] instead of Index, or the bytes package instead of strings.\n\nFixes are offered only in cases in which there are no potential modifications of the idx, s, or substr expressions between their definition and use.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stringscutprefix\"",
							"Doc": "replace HasPrefix/TrimPrefix with CutPrefix\n\nThe stringscutprefix analyzer simplifies a common pattern where code first\nchecks for a prefix with `strings.HasPrefix` and then removes it with\n`strings.TrimPrefix`. It replaces this two-step process with a single call\nto `strings.CutPrefix`, introduced in Go 1.20. The analyzer also handles\nthe equivalent functions in the `bytes` package.\n\nFor example, this input:\n\n\tif strings.HasPrefix(s, prefix) {\n\t    use(strings.TrimPrefix(s, prefix))\n\t}\n\nis fixed to:\n\n\tif after, ok := strings.CutPrefix(s, prefix); ok {\n\t    use(after)\n\t}\n\nThe analyzer also offers fixes to use CutSuffix in a similar way.\nThis input:\n\n\tif strings.HasSuffix(s, suffix) {\n\t    use(strings.TrimSuffix(s, suffix))\n\t}\n\nis fixed to:\n\n\tif before, ok := strings.CutSuffix(s, suffix); ok {\n\t    use(before)\n\t}",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"stringsseq\"",
							"Doc": "replace ranging over Split/Fields with SplitSeq/FieldsSeq\n\nThe stringsseq analyzer improves the efficiency of iterating over substrings.\nIt replaces\n\n\tfor range strings.Split(...)\n\nwith the more efficient\n\n\tfor range strings.SplitSeq(...)\n\nwhich was added in Go 1.24 and avoids allocating a slice for the\nsubstrings. The analyzer also handles strings.Fields and the\nequivalent functions in the bytes package.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"structtag\"",
							"Doc": "check that struct field tags conform to reflect.StructTag.Get\n\nAlso report certain struct tags (json, xml) used with unexported fields.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"testingcontext\"",
							"Doc": "replace context.WithCancel with t.Context in tests\n\nThe testingcontext analyzer simplifies context management in tests. It\nreplaces the manual creation of a cancellable context,\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\nwith a single call to t.Context(), which was added in Go 1.24.\n\nThis change is only suggested if the `cancel` function is not used\nfor any other purpose.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"testinggoroutine\"",
							"Doc": "report calls to (*testing.T).Fatal from goroutines started by a test\n\nFunctions that abruptly terminate a test, such as the Fatal, Fatalf, FailNow, and\nSkip{,f,Now} methods of *testing.T, must be called from the test goroutine itself.\nThis checker detects calls to these functions that occur within a goroutine\nstarted by the test. For example:\n\n\tfunc TestFoo(t *testing.T) {\n\t    go func() {\n\t        t.Fatal(\"oops\") // error: (*T).Fatal called from non-test goroutine\n\t    }()\n\t}",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"tests\"",
							"Doc": "check for common mistaken usages of tests and examples\n\nThe tests checker walks Test, Benchmark, Fuzzing and Example functions checking\nmalformed names, wrong signatures and examples documenting non-existent\nidentifiers.\n\nPlease see the documentation for package testing in golang.org/pkg/testing\nfor the conventions that are enforced for Tests, Benchmarks, and Examples.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"timeformat\"",
							"Doc": "check for calls of (time.Time).Format or time.Parse with 2006-02-01\n\nThe timeformat checker looks for time formats with the 2006-02-01 (yyyy-dd-mm)\nformat. Internationally, \"yyyy-dd-mm\" does not occur in common calendar date\nstandards, and so it is more likely that 2006-01-02 (yyyy-mm-dd) was intended.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unmarshal\"",
							"Doc": "report passing non-pointer or non-interface values to unmarshal\n\nThe unmarshal analysis reports calls to functions such as json.Unmarshal\nin which the argument type is not a pointer or an interface.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unreachable\"",
							"Doc": "check for unreachable code\n\nThe unreachable analyzer finds statements that execution can never reach\nbecause they are preceded by a return statement, a call to panic, an\ninfinite loop, or similar constructs.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unsafefuncs\"",
							"Doc": "replace unsafe pointer arithmetic with function calls\n\nThe unsafefuncs analyzer simplifies pointer arithmetic expressions by\nreplacing them with calls to helper functions such as unsafe.Add,\nadded in Go 1.17.\n\nExample:\n\n\tunsafe.Pointer(uintptr(ptr) + uintptr(n))\n\nwhere ptr is an unsafe.Pointer, is replaced by:\n\n\tunsafe.Add(ptr, n)",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unsafeptr\"",
							"Doc": "check for invalid conversions of uintptr to unsafe.Pointer\n\nThe unsafeptr analyzer reports likely incorrect uses of unsafe.Pointer\nto convert integers to pointers. A conversion from uintptr to\nunsafe.Pointer is invalid if it implies that there is a uintptr-typed\nword in memory that holds a pointer value, because that word will be\ninvisible to stack copying and to the garbage collector.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unusedfunc\"",
							"Doc": "check for unused functions, methods, etc\n\nThe unusedfunc analyzer reports functions and methods that are\nnever referenced outside of their own declaration.\n\nA function is considered unused if it is unexported and not\nreferenced (except within its own declaration).\n\nA method is considered unused if it is unexported, not referenced\n(except within its own declaration), and its name does not match\nthat of any method of an interface type declared within the same\npackage.\n\nThe tool may report false positives in some situations, for\nexample:\n\n  - for a declaration of an unexported function that is referenced\n    from another package using the go:linkname mechanism, if the\n    declaration's doc comment does not also have a go:linkname\n    comment.\n\n    (Such code is in any case strongly discouraged: linkname\n    annotations, if they must be used at all, should be used on both\n    the declaration and the alias.)\n\n  - for compiler intrinsics in the \"runtime\" package that, though\n    never referenced, are known to the compiler and are called\n    indirectly by compiled object code.\n\n  - for functions called only from assembly.\n\n  - for functions called only from files whose build tags are not\n    selected in the current build configuration.\n\nSince these situations are relatively common in the low-level parts\nof the runtime, this analyzer ignores the standard library.\nSee https://go.dev/issue/71686 and https://go.dev/issue/74130 for\nfurther discussion of these limitations.\n\nThe unusedfunc algorithm is not as precise as the\ngolang.org/x/tools/cmd/deadcode tool, but it has the advantage that\nit runs within the modular analysis framework, enabling near\nreal-time feedback within gopls.\n\nThe unusedfunc analyzer also reports unused types, vars, and\nconstants. Enums--constants defined with iota--are ignored since\neven the unused values must remain present to preserve the logical\nordering.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unusedparams\"",
							"Doc": "check for unused parameters of functions\n\nThe unusedparams analyzer checks functions to see if there are\nany parameters that are not being used.\n\nTo ensure soundness, it ignores:\n  - \"address-taken\" functions, that is, functions that are used as\n    a value rather than being called directly; their signatures may\n    be required to conform to a func type.\n  - exported functions or methods, since they may be address-taken\n    in another package.\n  - unexported methods whose name matches an interface method\n    declared in the same package, since the method's signature\n    may be required to conform to the interface type.\n  - functions with empty bodies, or containing just a call to panic.\n  - parameters that are unnamed, or named \"_\", the blank identifier.\n\nThe analyzer suggests a fix of replacing the parameter name by \"_\",\nbut in such cases a deeper fix can be obtained by invoking the\n\"Refactor: remove unused parameter\" code action, which will\neliminate the parameter entirely, along with all corresponding\narguments at call sites, while taking care to preserve any side\neffects in the argument expressions; see\nhttps://github.com/golang/tools/releases/tag/gopls%2Fv0.14.\n\nThis analyzer ignores generated code.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unusedresult\"",
							"Doc": "check for unused results of calls to some functions\n\nSome functions like fmt.Errorf return a result and have no side\neffects, so it is always a mistake to discard the result. Other\nfunctions may return an error that must not be ignored, or a cleanup\noperation that must be called. This analyzer reports calls to\nfunctions like these when the result of the call is ignored.\n\nThe set of functions may be controlled using flags.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unusedvariable\"",
							"Doc": "check for unused variables and suggest fixes",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"unusedwrite\"",
							"Doc": "checks for unused writes\n\nThe analyzer reports instances of writes to struct fields and\narrays that are never read. Specifically, when a struct object\nor an array is copied, its elements are copied implicitly by\nthe compiler, and any element write to this copy does nothing\nwith the original object.\n\nFor example:\n\n\ttype T struct { x int }\n\n\tfunc f(input []T) {\n\t\tfor i, v := range input {  // v is a copy\n\t\t\tv.x = i  // unused write to field x\n\t\t}\n\t}\n\nAnother example is about non-pointer receiver:\n\n\ttype T struct { x int }\n\n\tfunc (t T) f() {  // t is a copy\n\t\tt.x = i  // unused write to field x\n\t}",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"waitgroup\"",
							"Doc": "check for misuses of sync.WaitGroup\n\nThis analyzer detects mistaken calls to the (*sync.WaitGroup).Add\nmethod from inside a new goroutine, causing Add to race with Wait:\n\n\t// WRONG\n\tvar wg sync.WaitGroup\n\tgo func() {\n\t        wg.Add(1) // \"WaitGroup.Add called from inside new goroutine\"\n\t        defer wg.Done()\n\t        ...\n\t}()\n\twg.Wait() // (may return prematurely before new goroutine starts)\n\nThe correct code calls Add before starting the goroutine:\n\n\t// RIGHT\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t...\n\t}()\n\twg.Wait()",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"waitgroup\"",
							"Doc": "replace wg.Add(1)/go/wg.Done() with wg.Go\n\nThe waitgroup analyzer simplifies goroutine management with `sync.WaitGroup`.\nIt replaces the common pattern\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t...\n\t}()\n\nwith a single call to\n\n\twg.Go(func(){ ... })\n\nwhich was added in Go 1.25.",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"yield\"",
							"Doc": "report calls to yield where the result is ignored\n\nAfter a yield function returns false, the caller should not call\nthe yield function again; generally the iterator should return\npromptly.\n\nThis example fails to check the result of the call to yield,\ncausing this analyzer to report a diagnostic:\n\n\tyield(1) // yield may be called again (on L2) after returning false\n\tyield(2)\n\nThe corrected code is either this:\n\n\tif yield(1) { yield(2) }\n\nor simply:\n\n\t_ = yield(1) \u0026\u0026 yield(2)\n\nIt is not always a mistake to ignore the result of yield.\nFor example, this is a valid single-element iterator:\n\n\tyield(1) // ok to ignore result\n\treturn\n\nIt is only a mistake when the yield call that returned false may be\nfollowed by another call.",
							"Default": "true",
							"Status": ""
						}
					]
				},
				"EnumValues": null,
				"Default": "{}",
				"Status": "",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "staticcheck",
				"Type": "bool",
				"Doc": "staticcheck configures the default set of analyses staticcheck.io.\nThese analyses are documented on\n[Staticcheck's website](https://staticcheck.io/docs/checks/).\n\nThe \"staticcheck\" option has three values:\n- false: disable all staticcheck analyzers\n- true: enable all staticcheck analyzers\n- unset: enable a subset of staticcheck analyzers\n  selected by gopls maintainers for runtime efficiency\n  and analytic precision.\n\nRegardless of this setting, individual analyzers can be\nselectively enabled or disabled using the `analyses` setting.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "experimental",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "staticcheckProvided",
				"Type": "bool",
				"Doc": "",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "experimental",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "annotations",
				"Type": "map[enum]bool",
				"Doc": "annotations specifies the various kinds of compiler\noptimization details that should be reported as diagnostics\nwhen enabled for a package by the \"Toggle compiler\noptimization details\" (`gopls.gc_details`) command.\n\n(Some users care only about one kind of annotation in their\nprofiling efforts. More importantly, in large packages, the\nnumber of annotations can sometimes overwhelm the user\ninterface and exceed the per-file diagnostic limit.)\n\nTODO(adonovan): rename this field to CompilerOptDetail.\n",
				"EnumKeys": {
					"ValueType": "bool",
					"Keys": [
						{
							"Name": "\"bounds\"",
							"Doc": "`\"bounds\"` controls bounds checking diagnostics.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"escape\"",
							"Doc": "`\"escape\"` controls diagnostics about escape choices.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"inline\"",
							"Doc": "`\"inline\"` controls diagnostics about inlining choices.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"nil\"",
							"Doc": "`\"nil\"` controls nil checks.\n",
							"Default": "true",
							"Status": ""
						}
					]
				},
				"EnumValues": null,
				"Default": "{\"bounds\":true,\"escape\":true,\"inline\":true,\"nil\":true}",
				"Status": "",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "vulncheck",
				"Type": "enum",
				"Doc": "vulncheck enables vulnerability scanning.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"Imports\"",
						"Doc": "`\"Imports\"`: In Imports mode, `gopls` will report vulnerabilities that affect packages\ndirectly and indirectly used by the analyzed main module.\n",
						"Status": ""
					},
					{
						"Value": "\"Off\"",
						"Doc": "`\"Off\"`: Disable vulnerability analysis.\n",
						"Status": ""
					},
					{
						"Value": "\"Prompt\"",
						"Doc": "`\"Prompt\"`: Vulncheck can be triggered via prompt.\n",
						"Status": ""
					}
				],
				"Default": "\"Prompt\"",
				"Status": "experimental",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "diagnosticsDelay",
				"Type": "time.Duration",
				"Doc": "diagnosticsDelay controls the amount of time that gopls waits\nafter the most recent file modification before computing deep diagnostics.\nSimple diagnostics (parsing and type-checking) are always run immediately\non recently modified packages.\n\nThis option must be set to a valid duration string, for example `\"250ms\"`.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "\"1s\"",
				"Status": "advanced",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "diagnosticsTrigger",
				"Type": "enum",
				"Doc": "diagnosticsTrigger controls when to run diagnostics.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": [
					{
						"Value": "\"Edit\"",
						"Doc": "`\"Edit\"`: Trigger diagnostics on file edit and save. (default)\n",
						"Status": ""
					},
					{
						"Value": "\"Save\"",
						"Doc": "`\"Save\"`: Trigger diagnostics only on file save. Events like initial workspace load\nor configuration change will still trigger diagnostics.\n",
						"Status": ""
					}
				],
				"Default": "\"Edit\"",
				"Status": "experimental",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "analysisProgressReporting",
				"Type": "bool",
				"Doc": "analysisProgressReporting controls whether gopls sends progress\nnotifications when construction of its index of analysis facts is taking a\nlong time. Cancelling these notifications will cancel the indexing task,\nthough it will restart after the next change in the workspace.\n\nWhen a package is opened for the first time and heavyweight analyses such as\nstaticcheck are enabled, it can take a while to construct the index of\nanalysis facts for all its dependencies. The index is cached in the\nfilesystem, so subsequent analysis should be faster.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "true",
				"Status": "",
				"Hierarchy": "ui.diagnostic",
				"DeprecationMessage": ""
			},
			{
				"Name": "hints",
				"Type": "map[enum]bool",
				"Doc": "hints specify inlay hints that users want to see. A full list of hints\nthat gopls uses can be found in\n[inlayHints.md](https://github.com/golang/tools/blob/master/gopls/doc/inlayHints.md).\n",
				"EnumKeys": {
					"ValueType": "bool",
					"Keys": [
						{
							"Name": "\"assignVariableTypes\"",
							"Doc": "`\"assignVariableTypes\"` controls inlay hints for variable types in assign statements:\n```go\n\ti/* int*/, j/* int*/ := 0, len(r)-1\n```\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"compositeLiteralFields\"",
							"Doc": "`\"compositeLiteralFields\"` inlay hints for composite literal field names:\n```go\n\t{/*in: */\"Hello, world\", /*want: */\"dlrow ,olleH\"}\n```\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"compositeLiteralTypes\"",
							"Doc": "`\"compositeLiteralTypes\"` controls inlay hints for composite literal types:\n```go\n\tfor _, c := range []struct {\n\t\tin, want string\n\t}{\n\t\t/*struct{ in string; want string }*/{\"Hello, world\", \"dlrow ,olleH\"},\n\t}\n```\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"constantValues\"",
							"Doc": "`\"constantValues\"` controls inlay hints for constant values:\n```go\n\tconst (\n\t\tKindNone   Kind = iota/* = 0*/\n\t\tKindPrint/*  = 1*/\n\t\tKindPrintf/* = 2*/\n\t\tKindErrorf/* = 3*/\n\t)\n```\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"functionTypeParameters\"",
							"Doc": "`\"functionTypeParameters\"` inlay hints for implicit type parameters on generic functions:\n```go\n\tmyFoo/*[int, string]*/(1, \"hello\")\n```\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"ignoredError\"",
							"Doc": "`\"ignoredError\"` inlay hints for implicitly discarded errors:\n```go\n\tf.Close() // ignore error\n```\nThis check inserts an `// ignore error` hint following any\nstatement that is a function call whose error result is\nimplicitly ignored.\n\nTo suppress the hint, write an actual comment containing\n\"ignore error\" following the call statement, or explictly\nassign the result to a blank variable. A handful of common\nfunctions such as `fmt.Println` are excluded from the\ncheck.\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"parameterNames\"",
							"Doc": "`\"parameterNames\"` controls inlay hints for parameter names:\n```go\n\tparseInt(/* str: */ \"123\", /* radix: */ 8)\n```\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"rangeVariableTypes\"",
							"Doc": "`\"rangeVariableTypes\"` controls inlay hints for variable types in range statements:\n```go\n\tfor k/* int*/, v/* string*/ := range []string{} {\n\t\tfmt.Println(k, v)\n\t}\n```\n",
							"Default": "false",
							"Status": ""
						}
					]
				},
				"EnumValues": null,
				"Default": "{}",
				"Status": "experimental",
				"Hierarchy": "ui.inlayhint",
				"DeprecationMessage": ""
			},
			{
				"Name": "codelenses",
				"Type": "map[enum]bool",
				"Doc": "codelenses overrides the enabled/disabled state of each of gopls'\nsources of [Code Lenses](codelenses.md).\n\nExample Usage:\n\n```json5\n\"gopls\": {\n...\n  \"codelenses\": {\n    \"generate\": false,  // Don't show the `go generate` lens.\n  }\n...\n}\n```\n",
				"EnumKeys": {
					"ValueType": "bool",
					"Keys": [
						{
							"Name": "\"generate\"",
							"Doc": "`\"generate\"`: Run `go generate`\n\nThis codelens source annotates any `//go:generate` comments\nwith commands to run `go generate` in this directory, on\nall directories recursively beneath this one.\n\nSee [Generating code](https://go.dev/blog/generate) for\nmore details.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"regenerate_cgo\"",
							"Doc": "`\"regenerate_cgo\"`: Re-generate cgo declarations\n\nThis codelens source annotates an `import \"C\"` declaration\nwith a command to re-run the [cgo\ncommand](https://pkg.go.dev/cmd/cgo) to regenerate the\ncorresponding Go declarations.\n\nUse this after editing the C code in comments attached to\nthe import, or in C header files included by it.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"run_govulncheck\"",
							"Doc": "`\"run_govulncheck\"`: Run govulncheck (legacy)\n\nThis codelens source annotates the `module` directive in a go.mod file\nwith a command to run Govulncheck asynchronously.\n\n[Govulncheck](https://go.dev/blog/vuln) is a static analysis tool that\ncomputes the set of functions reachable within your application, including\ndependencies; queries a database of known security vulnerabilities; and\nreports any potential problems it finds.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"test\"",
							"Doc": "`\"test\"`: Run tests and benchmarks\n\nThis codelens source annotates each `Test` and `Benchmark`\nfunction in a `*_test.go` file with a command to run it.\n\nThis source is off by default because VS Code has\na client-side custom UI for testing, and because progress\nnotifications are not a great UX for streamed test output.\nSee:\n- golang/go#67400 for a discussion of this feature.\n- https://github.com/joaotavora/eglot/discussions/1402\n  for an alternative approach.\n",
							"Default": "false",
							"Status": ""
						},
						{
							"Name": "\"tidy\"",
							"Doc": "`\"tidy\"`: Tidy go.mod file\n\nThis codelens source annotates the `module` directive in a\ngo.mod file with a command to run [`go mod\ntidy`](https://go.dev/ref/mod#go-mod-tidy), which ensures\nthat the go.mod file matches the source code in the module.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"upgrade_dependency\"",
							"Doc": "`\"upgrade_dependency\"`: Update dependencies\n\nThis codelens source annotates the `module` directive in a\ngo.mod file with commands to:\n\n- check for available upgrades,\n- upgrade direct dependencies, and\n- upgrade all dependencies transitively.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"vendor\"",
							"Doc": "`\"vendor\"`: Update vendor directory\n\nThis codelens source annotates the `module` directive in a\ngo.mod file with a command to run [`go mod\nvendor`](https://go.dev/ref/mod#go-mod-vendor), which\ncreates or updates the directory named `vendor` in the\nmodule root so that it contains an up-to-date copy of all\nnecessary package dependencies.\n",
							"Default": "true",
							"Status": ""
						},
						{
							"Name": "\"vulncheck\"",
							"Doc": "`\"vulncheck\"`: Run govulncheck\n\nThis codelens source annotates the `module` directive in a go.mod file\nwith a command to run govulncheck synchronously.\n\n[Govulncheck](https://go.dev/blog/vuln) is a static analysis tool that\ncomputes the set of functions reachable within your application, including\ndependencies; queries a database of known security vulnerabilities; and\nreports any potential problems it finds.\n",
							"Default": "false",
							"Status": "experimental"
						}
					]
				},
				"EnumValues": null,
				"Default": "{\"generate\":true,\"regenerate_cgo\":true,\"run_govulncheck\":true,\"tidy\":true,\"upgrade_dependency\":true,\"vendor\":true}",
				"Status": "",
				"Hierarchy": "ui",
				"DeprecationMessage": ""
			},
			{
				"Name": "semanticTokens",
				"Type": "bool",
				"Doc": "semanticTokens controls whether the LSP server will send\nsemantic tokens to the client.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "experimental",
				"Hierarchy": "ui",
				"DeprecationMessage": ""
			},
			{
				"Name": "noSemanticString",
				"Type": "bool",
				"Doc": "noSemanticString turns off the sending of the semantic token 'string'\n\nDeprecated: Use SemanticTokenTypes[\"string\"] = false instead. See\ngolang/vscode-go#3632\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "experimental",
				"Hierarchy": "ui",
				"DeprecationMessage": "use SemanticTokenTypes[\"string\"] = false instead. See\ngolang/vscode-go#3632\n"
			},
			{
				"Name": "noSemanticNumber",
				"Type": "bool",
				"Doc": "noSemanticNumber turns off the sending of the semantic token 'number'\n\nDeprecated: Use SemanticTokenTypes[\"number\"] = false instead. See\ngolang/vscode-go#3632.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "experimental",
				"Hierarchy": "ui",
				"DeprecationMessage": "use SemanticTokenTypes[\"number\"] = false instead. See\ngolang/vscode-go#3632.\n"
			},
			{
				"Name": "semanticTokenTypes",
				"Type": "map[string]bool",
				"Doc": "semanticTokenTypes configures the semantic token types. It allows\ndisabling types by setting each value to false.\nBy default, all types are enabled.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "{}",
				"Status": "experimental",
				"Hierarchy": "ui",
				"DeprecationMessage": ""
			},
			{
				"Name": "semanticTokenModifiers",
				"Type": "map[string]bool",
				"Doc": "semanticTokenModifiers configures the semantic token modifiers. It allows\ndisabling modifiers by setting each value to false.\nBy default, all modifiers are enabled.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "{}",
				"Status": "experimental",
				"Hierarchy": "ui",
				"DeprecationMessage": ""
			},
			{
				"Name": "newGoFileHeader",
				"Type": "bool",
				"Doc": "newGoFileHeader enables automatic insertion of the copyright comment\nand package declaration in a newly created Go file.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "true",
				"Status": "",
				"Hierarchy": "ui",
				"DeprecationMessage": ""
			},
			{
				"Name": "renameMovesSubpackages",
				"Type": "bool",
				"Doc": "renameMovesSubpackages enables Rename operations on packages to\nmove subdirectories of the target package.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "experimental",
				"Hierarchy": "ui",
				"DeprecationMessage": ""
			},
			{
				"Name": "local",
				"Type": "string",
				"Doc": "local is the equivalent of the `goimports -local` flag, which puts\nimports beginning with this string after third-party packages. It should\nbe the prefix of the import path whose imports should be grouped\nseparately.\n\nIt is used when tidying imports (during an LSP Organize\nImports request) or when inserting new ones (for example,\nduring completion); an LSP Formatting request merely sorts the\nexisting imports.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "\"\"",
				"Status": "",
				"Hierarchy": "formatting",
				"DeprecationMessage": ""
			},
			{
				"Name": "gofumpt",
				"Type": "bool",
				"Doc": "gofumpt indicates if we should run gofumpt formatting.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "",
				"Hierarchy": "formatting",
				"DeprecationMessage": ""
			},
			{
				"Name": "verboseOutput",
				"Type": "bool",
				"Doc": "verboseOutput enables additional debug logging.\n",
				"EnumKeys": {
					"ValueType": "",
					"Keys": null
				},
				"EnumValues": null,
				"Default": "false",
				"Status": "debug",
				"Hierarchy": "",
				"DeprecationMessage": ""
			}
		]
	},
	"Lenses": [
		{
			"FileType": "Go",
			"Lens": "generate",
			"Title": "Run `go generate`",
			"Doc": "\nThis codelens source annotates any `//go:generate` comments\nwith commands to run `go generate` in this directory, on\nall directories recursively beneath this one.\n\nSee [Generating code](https://go.dev/blog/generate) for\nmore details.\n",
			"Default": true,
			"Status": ""
		},
		{
			"FileType": "Go",
			"Lens": "regenerate_cgo",
			"Title": "Re-generate cgo declarations",
			"Doc": "\nThis codelens source annotates an `import \"C\"` declaration\nwith a command to re-run the [cgo\ncommand](https://pkg.go.dev/cmd/cgo) to regenerate the\ncorresponding Go declarations.\n\nUse this after editing the C code in comments attached to\nthe import, or in C header files included by it.\n",
			"Default": true,
			"Status": ""
		},
		{
			"FileType": "Go",
			"Lens": "test",
			"Title": "Run tests and benchmarks",
			"Doc": "\nThis codelens source annotates each `Test` and `Benchmark`\nfunction in a `*_test.go` file with a command to run it.\n\nThis source is off by default because VS Code has\na client-side custom UI for testing, and because progress\nnotifications are not a great UX for streamed test output.\nSee:\n- golang/go#67400 for a discussion of this feature.\n- https://github.com/joaotavora/eglot/discussions/1402\n  for an alternative approach.\n",
			"Default": false,
			"Status": ""
		},
		{
			"FileType": "go.mod",
			"Lens": "run_govulncheck",
			"Title": "Run govulncheck (legacy)",
			"Doc": "\nThis codelens source annotates the `module` directive in a go.mod file\nwith a command to run Govulncheck asynchronously.\n\n[Govulncheck](https://go.dev/blog/vuln) is a static analysis tool that\ncomputes the set of functions reachable within your application, including\ndependencies; queries a database of known security vulnerabilities; and\nreports any potential problems it finds.\n",
			"Default": true,
			"Status": ""
		},
		{
			"FileType": "go.mod",
			"Lens": "tidy",
			"Title": "Tidy go.mod file",
			"Doc": "\nThis codelens source annotates the `module` directive in a\ngo.mod file with a command to run [`go mod\ntidy`](https://go.dev/ref/mod#go-mod-tidy), which ensures\nthat the go.mod file matches the source code in the module.\n",
			"Default": true,
			"Status": ""
		},
		{
			"FileType": "go.mod",
			"Lens": "upgrade_dependency",
			"Title": "Update dependencies",
			"Doc": "\nThis codelens source annotates the `module` directive in a\ngo.mod file with commands to:\n\n- check for available upgrades,\n- upgrade direct dependencies, and\n- upgrade all dependencies transitively.\n",
			"Default": true,
			"Status": ""
		},
		{
			"FileType": "go.mod",
			"Lens": "vendor",
			"Title": "Update vendor directory",
			"Doc": "\nThis codelens source annotates the `module` directive in a\ngo.mod file with a command to run [`go mod\nvendor`](https://go.dev/ref/mod#go-mod-vendor), which\ncreates or updates the directory named `vendor` in the\nmodule root so that it contains an up-to-date copy of all\nnecessary package dependencies.\n",
			"Default": true,
			"Status": ""
		},
		{
			"FileType": "go.mod",
			"Lens": "vulncheck",
			"Title": "Run govulncheck",
			"Doc": "\nThis codelens source annotates the `module` directive in a go.mod file\nwith a command to run govulncheck synchronously.\n\n[Govulncheck](https://go.dev/blog/vuln) is a static analysis tool that\ncomputes the set of functions reachable within your application, including\ndependencies; queries a database of known security vulnerabilities; and\nreports any potential problems it finds.\n",
			"Default": false,
			"Status": "experimental"
		}
	],
	"Analyzers": [
		{
			"Name": "QF1001",
			"Doc": "Apply De Morgan's law\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1001",
			"Default": false
		},
		{
			"Name": "QF1002",
			"Doc": "Convert untagged switch to tagged switch\n\nAn untagged switch that compares a single variable against a series of\nvalues can be replaced with a tagged switch.\n\nBefore:\n\n    switch {\n    case x == 1 || x == 2, x == 3:\n        ...\n    case x == 4:\n        ...\n    default:\n        ...\n    }\n\nAfter:\n\n    switch x {\n    case 1, 2, 3:\n        ...\n    case 4:\n        ...\n    default:\n        ...\n    }\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1002",
			"Default": true
		},
		{
			"Name": "QF1003",
			"Doc": "Convert if/else-if chain to tagged switch\n\nA series of if/else-if checks comparing the same variable against\nvalues can be replaced with a tagged switch.\n\nBefore:\n\n    if x == 1 || x == 2 {\n        ...\n    } else if x == 3 {\n        ...\n    } else {\n        ...\n    }\n\nAfter:\n\n    switch x {\n    case 1, 2:\n        ...\n    case 3:\n        ...\n    default:\n        ...\n    }\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1003",
			"Default": true
		},
		{
			"Name": "QF1004",
			"Doc": "Use strings.ReplaceAll instead of strings.Replace with n == -1\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1004",
			"Default": true
		},
		{
			"Name": "QF1005",
			"Doc": "Expand call to math.Pow\n\nSome uses of math.Pow can be simplified to basic multiplication.\n\nBefore:\n\n    math.Pow(x, 2)\n\nAfter:\n\n    x * x\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1005",
			"Default": false
		},
		{
			"Name": "QF1006",
			"Doc": "Lift if+break into loop condition\n\nBefore:\n\n    for {\n        if done {\n            break\n        }\n        ...\n    }\n\nAfter:\n\n    for !done {\n        ...\n    }\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1006",
			"Default": false
		},
		{
			"Name": "QF1007",
			"Doc": "Merge conditional assignment into variable declaration\n\nBefore:\n\n    x := false\n    if someCondition {\n        x = true\n    }\n\nAfter:\n\n    x := someCondition\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1007",
			"Default": false
		},
		{
			"Name": "QF1008",
			"Doc": "Omit embedded fields from selector expression\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1008",
			"Default": false
		},
		{
			"Name": "QF1009",
			"Doc": "Use time.Time.Equal instead of == operator\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1009",
			"Default": true
		},
		{
			"Name": "QF1010",
			"Doc": "Convert slice of bytes to string when printing it\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1010",
			"Default": true
		},
		{
			"Name": "QF1011",
			"Doc": "Omit redundant type from variable declaration\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#",
			"Default": false
		},
		{
			"Name": "QF1012",
			"Doc": "Use fmt.Fprintf(x, ...) instead of x.Write(fmt.Sprintf(...))\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#QF1012",
			"Default": true
		},
		{
			"Name": "S1000",
			"Doc": "Use plain channel send or receive instead of single-case select\n\nSelect statements with a single case can be replaced with a simple\nsend or receive.\n\nBefore:\n\n    select {\n    case x := \u003c-ch:\n        fmt.Println(x)\n    }\n\nAfter:\n\n    x := \u003c-ch\n    fmt.Println(x)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1000",
			"Default": true
		},
		{
			"Name": "S1001",
			"Doc": "Replace for loop with call to copy\n\nUse copy() for copying elements from one slice to another. For\narrays of identical size, you can use simple assignment.\n\nBefore:\n\n    for i, x := range src {\n        dst[i] = x\n    }\n\nAfter:\n\n    copy(dst, src)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1001",
			"Default": true
		},
		{
			"Name": "S1002",
			"Doc": "Omit comparison with boolean constant\n\nBefore:\n\n    if x == true {}\n\nAfter:\n\n    if x {}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1002",
			"Default": false
		},
		{
			"Name": "S1003",
			"Doc": "Replace call to strings.Index with strings.Contains\n\nBefore:\n\n    if strings.Index(x, y) != -1 {}\n\nAfter:\n\n    if strings.Contains(x, y) {}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1003",
			"Default": true
		},
		{
			"Name": "S1004",
			"Doc": "Replace call to bytes.Compare with bytes.Equal\n\nBefore:\n\n    if bytes.Compare(x, y) == 0 {}\n\nAfter:\n\n    if bytes.Equal(x, y) {}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1004",
			"Default": true
		},
		{
			"Name": "S1005",
			"Doc": "Drop unnecessary use of the blank identifier\n\nIn many cases, assigning to the blank identifier is unnecessary.\n\nBefore:\n\n    for _ = range s {}\n    x, _ = someMap[key]\n    _ = \u003c-ch\n\nAfter:\n\n    for range s{}\n    x = someMap[key]\n    \u003c-ch\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1005",
			"Default": false
		},
		{
			"Name": "S1006",
			"Doc": "Use 'for { ... }' for infinite loops\n\nFor infinite loops, using for { ... } is the most idiomatic choice.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1006",
			"Default": false
		},
		{
			"Name": "S1007",
			"Doc": "Simplify regular expression by using raw string literal\n\nRaw string literals use backticks instead of quotation marks and do not support\nany escape sequences. This means that the backslash can be used\nfreely, without the need of escaping.\n\nSince regular expressions have their own escape sequences, raw strings\ncan improve their readability.\n\nBefore:\n\n    regexp.Compile(\"\\\\A(\\\\w+) profile: total \\\\d+\\\\n\\\\z\")\n\nAfter:\n\n    regexp.Compile(`\\A(\\w+) profile: total \\d+\\n\\z`)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1007",
			"Default": true
		},
		{
			"Name": "S1008",
			"Doc": "Simplify returning boolean expression\n\nBefore:\n\n    if \u003cexpr\u003e {\n        return true\n    }\n    return false\n\nAfter:\n\n    return \u003cexpr\u003e\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1008",
			"Default": false
		},
		{
			"Name": "S1009",
			"Doc": "Omit redundant nil check on slices, maps, and channels\n\nThe len function is defined for all slices, maps, and\nchannels, even nil ones, which have a length of zero. It is not necessary to\ncheck for nil before checking that their length is not zero.\n\nBefore:\n\n    if x != nil \u0026\u0026 len(x) != 0 {}\n\nAfter:\n\n    if len(x) != 0 {}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1009",
			"Default": true
		},
		{
			"Name": "S1010",
			"Doc": "Omit default slice index\n\nWhen slicing, the second index defaults to the length of the value,\nmaking s[n:len(s)] and s[n:] equivalent.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1010",
			"Default": true
		},
		{
			"Name": "S1011",
			"Doc": "Use a single append to concatenate two slices\n\nBefore:\n\n    for _, e := range y {\n        x = append(x, e)\n    }\n    \n    for i := range y {\n        x = append(x, y[i])\n    }\n    \n    for i := range y {\n        v := y[i]\n        x = append(x, v)\n    }\n\nAfter:\n\n    x = append(x, y...)\n    x = append(x, y...)\n    x = append(x, y...)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1011",
			"Default": false
		},
		{
			"Name": "S1012",
			"Doc": "Replace time.Now().Sub(x) with time.Since(x)\n\nThe time.Since helper has the same effect as using time.Now().Sub(x)\nbut is easier to read.\n\nBefore:\n\n    time.Now().Sub(x)\n\nAfter:\n\n    time.Since(x)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1012",
			"Default": true
		},
		{
			"Name": "S1016",
			"Doc": "Use a type conversion instead of manually copying struct fields\n\nTwo struct types with identical fields can be converted between each\nother. In older versions of Go, the fields had to have identical\nstruct tags. Since Go 1.8, however, struct tags are ignored during\nconversions. It is thus not necessary to manually copy every field\nindividually.\n\nBefore:\n\n    var x T1\n    y := T2{\n        Field1: x.Field1,\n        Field2: x.Field2,\n    }\n\nAfter:\n\n    var x T1\n    y := T2(x)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1016",
			"Default": false
		},
		{
			"Name": "S1017",
			"Doc": "Replace manual trimming with strings.TrimPrefix\n\nInstead of using strings.HasPrefix and manual slicing, use the\nstrings.TrimPrefix function. If the string doesn't start with the\nprefix, the original string will be returned. Using strings.TrimPrefix\nreduces complexity, and avoids common bugs, such as off-by-one\nmistakes.\n\nBefore:\n\n    if strings.HasPrefix(str, prefix) {\n        str = str[len(prefix):]\n    }\n\nAfter:\n\n    str = strings.TrimPrefix(str, prefix)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1017",
			"Default": true
		},
		{
			"Name": "S1018",
			"Doc": "Use 'copy' for sliding elements\n\ncopy() permits using the same source and destination slice, even with\noverlapping ranges. This makes it ideal for sliding elements in a\nslice.\n\nBefore:\n\n    for i := 0; i \u003c n; i++ {\n        bs[i] = bs[offset+i]\n    }\n\nAfter:\n\n    copy(bs[:n], bs[offset:])\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1018",
			"Default": true
		},
		{
			"Name": "S1019",
			"Doc": "Simplify 'make' call by omitting redundant arguments\n\nThe 'make' function has default values for the length and capacity\narguments. For channels, the length defaults to zero, and for slices,\nthe capacity defaults to the length.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1019",
			"Default": true
		},
		{
			"Name": "S1020",
			"Doc": "Omit redundant nil check in type assertion\n\nBefore:\n\n    if _, ok := i.(T); ok \u0026\u0026 i != nil {}\n\nAfter:\n\n    if _, ok := i.(T); ok {}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1020",
			"Default": true
		},
		{
			"Name": "S1021",
			"Doc": "Merge variable declaration and assignment\n\nBefore:\n\n    var x uint\n    x = 1\n\nAfter:\n\n    var x uint = 1\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1021",
			"Default": false
		},
		{
			"Name": "S1023",
			"Doc": "Omit redundant control flow\n\nFunctions that have no return value do not need a return statement as\nthe final statement of the function.\n\nSwitches in Go do not have automatic fallthrough, unlike languages\nlike C. It is not necessary to have a break statement as the final\nstatement in a case block.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1023",
			"Default": true
		},
		{
			"Name": "S1024",
			"Doc": "Replace x.Sub(time.Now()) with time.Until(x)\n\nThe time.Until helper has the same effect as using x.Sub(time.Now())\nbut is easier to read.\n\nBefore:\n\n    x.Sub(time.Now())\n\nAfter:\n\n    time.Until(x)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1024",
			"Default": true
		},
		{
			"Name": "S1025",
			"Doc": "Don't use fmt.Sprintf(\"%s\", x) unnecessarily\n\nIn many instances, there are easier and more efficient ways of getting\na value's string representation. Whenever a value's underlying type is\na string already, or the type has a String method, they should be used\ndirectly.\n\nGiven the following shared definitions\n\n    type T1 string\n    type T2 int\n\n    func (T2) String() string { return \"Hello, world\" }\n\n    var x string\n    var y T1\n    var z T2\n\nwe can simplify\n\n    fmt.Sprintf(\"%s\", x)\n    fmt.Sprintf(\"%s\", y)\n    fmt.Sprintf(\"%s\", z)\n\nto\n\n    x\n    string(y)\n    z.String()\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1025",
			"Default": false
		},
		{
			"Name": "S1028",
			"Doc": "Simplify error construction with fmt.Errorf\n\nBefore:\n\n    errors.New(fmt.Sprintf(...))\n\nAfter:\n\n    fmt.Errorf(...)\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1028",
			"Default": true
		},
		{
			"Name": "S1029",
			"Doc": "Range over the string directly\n\nRanging over a string will yield byte offsets and runes. If the offset\nisn't used, this is functionally equivalent to converting the string\nto a slice of runes and ranging over that. Ranging directly over the\nstring will be more performant, however, as it avoids allocating a new\nslice, the size of which depends on the length of the string.\n\nBefore:\n\n    for _, r := range []rune(s) {}\n\nAfter:\n\n    for _, r := range s {}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1029",
			"Default": false
		},
		{
			"Name": "S1030",
			"Doc": "Use bytes.Buffer.String or bytes.Buffer.Bytes\n\nbytes.Buffer has both a String and a Bytes method. It is almost never\nnecessary to use string(buf.Bytes()) or []byte(buf.String()) – simply\nuse the other method.\n\nThe only exception to this are map lookups. Due to a compiler optimization,\nm[string(buf.Bytes())] is more efficient than m[buf.String()].\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1030",
			"Default": true
		},
		{
			"Name": "S1031",
			"Doc": "Omit redundant nil check around loop\n\nYou can use range on nil slices and maps, the loop will simply never\nexecute. This makes an additional nil check around the loop\nunnecessary.\n\nBefore:\n\n    if s != nil {\n        for _, x := range s {\n            ...\n        }\n    }\n\nAfter:\n\n    for _, x := range s {\n        ...\n    }\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1031",
			"Default": true
		},
		{
			"Name": "S1032",
			"Doc": "Use sort.Ints(x), sort.Float64s(x), and sort.Strings(x)\n\nThe sort.Ints, sort.Float64s and sort.Strings functions are easier to\nread than sort.Sort(sort.IntSlice(x)), sort.Sort(sort.Float64Slice(x))\nand sort.Sort(sort.StringSlice(x)).\n\nBefore:\n\n    sort.Sort(sort.StringSlice(x))\n\nAfter:\n\n    sort.Strings(x)\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1032",
			"Default": true
		},
		{
			"Name": "S1033",
			"Doc": "Unnecessary guard around call to 'delete'\n\nCalling delete on a nil map is a no-op.\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1033",
			"Default": true
		},
		{
			"Name": "S1034",
			"Doc": "Use result of type assertion to simplify cases\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1034",
			"Default": true
		},
		{
			"Name": "S1035",
			"Doc": "Redundant call to net/http.CanonicalHeaderKey in method call on net/http.Header\n\nThe methods on net/http.Header, namely Add, Del, Get\nand Set, already canonicalize the given header name.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1035",
			"Default": true
		},
		{
			"Name": "S1036",
			"Doc": "Unnecessary guard around map access\n\nWhen accessing a map key that doesn't exist yet, one receives a zero\nvalue. Often, the zero value is a suitable value, for example when\nusing append or doing integer math.\n\nThe following\n\n    if _, ok := m[\"foo\"]; ok {\n        m[\"foo\"] = append(m[\"foo\"], \"bar\")\n    } else {\n        m[\"foo\"] = []string{\"bar\"}\n    }\n\ncan be simplified to\n\n    m[\"foo\"] = append(m[\"foo\"], \"bar\")\n\nand\n\n    if _, ok := m2[\"k\"]; ok {\n        m2[\"k\"] += 4\n    } else {\n        m2[\"k\"] = 4\n    }\n\ncan be simplified to\n\n    m[\"k\"] += 4\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1036",
			"Default": true
		},
		{
			"Name": "S1037",
			"Doc": "Elaborate way of sleeping\n\nUsing a select statement with a single case receiving\nfrom the result of time.After is a very elaborate way of sleeping that\ncan much simpler be expressed with a simple call to time.Sleep.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1037",
			"Default": true
		},
		{
			"Name": "S1038",
			"Doc": "Unnecessarily complex way of printing formatted string\n\nInstead of using fmt.Print(fmt.Sprintf(...)), one can use fmt.Printf(...).\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1038",
			"Default": true
		},
		{
			"Name": "S1039",
			"Doc": "Unnecessary use of fmt.Sprint\n\nCalling fmt.Sprint with a single string argument is unnecessary\nand identical to using the string directly.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1039",
			"Default": true
		},
		{
			"Name": "S1040",
			"Doc": "Type assertion to current type\n\nThe type assertion x.(SomeInterface), when x already has type\nSomeInterface, can only fail if x is nil. Usually, this is\nleft-over code from when x had a different type and you can safely\ndelete the type assertion. If you want to check that x is not nil,\nconsider being explicit and using an actual if x == nil comparison\ninstead of relying on the type assertion panicking.\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#S1040",
			"Default": true
		},
		{
			"Name": "SA1000",
			"Doc": "Invalid regular expression\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1000",
			"Default": false
		},
		{
			"Name": "SA1001",
			"Doc": "Invalid template\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1001",
			"Default": true
		},
		{
			"Name": "SA1002",
			"Doc": "Invalid format in time.Parse\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1002",
			"Default": false
		},
		{
			"Name": "SA1003",
			"Doc": "Unsupported argument to functions in encoding/binary\n\nThe encoding/binary package can only serialize types with known sizes.\nThis precludes the use of the int and uint types, as their sizes\ndiffer on different architectures. Furthermore, it doesn't support\nserializing maps, channels, strings, or functions.\n\nBefore Go 1.8, bool wasn't supported, either.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1003",
			"Default": false
		},
		{
			"Name": "SA1004",
			"Doc": "Suspiciously small untyped constant in time.Sleep\n\nThe time.Sleep function takes a time.Duration as its only argument.\nDurations are expressed in nanoseconds. Thus, calling time.Sleep(1)\nwill sleep for 1 nanosecond. This is a common source of bugs, as sleep\nfunctions in other languages often accept seconds or milliseconds.\n\nThe time package provides constants such as time.Second to express\nlarge durations. These can be combined with arithmetic to express\narbitrary durations, for example 5 * time.Second for 5 seconds.\n\nIf you truly meant to sleep for a tiny amount of time, use\nn * time.Nanosecond to signal to Staticcheck that you did mean to sleep\nfor some amount of nanoseconds.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1004",
			"Default": true
		},
		{
			"Name": "SA1005",
			"Doc": "Invalid first argument to exec.Command\n\nos/exec runs programs directly (using variants of the fork and exec\nsystem calls on Unix systems). This shouldn't be confused with running\na command in a shell. The shell will allow for features such as input\nredirection, pipes, and general scripting. The shell is also\nresponsible for splitting the user's input into a program name and its\narguments. For example, the equivalent to\n\n    ls / /tmp\n\nwould be\n\n    exec.Command(\"ls\", \"/\", \"/tmp\")\n\nIf you want to run a command in a shell, consider using something like\nthe following – but be aware that not all systems, particularly\nWindows, will have a /bin/sh program:\n\n    exec.Command(\"/bin/sh\", \"-c\", \"ls | grep Awesome\")\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1005",
			"Default": true
		},
		{
			"Name": "SA1007",
			"Doc": "Invalid URL in net/url.Parse\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1007",
			"Default": false
		},
		{
			"Name": "SA1008",
			"Doc": "Non-canonical key in http.Header map\n\nKeys in http.Header maps are canonical, meaning they follow a specific\ncombination of uppercase and lowercase letters. Methods such as\nhttp.Header.Add and http.Header.Del convert inputs into this canonical\nform before manipulating the map.\n\nWhen manipulating http.Header maps directly, as opposed to using the\nprovided methods, care should be taken to stick to canonical form in\norder to avoid inconsistencies. The following piece of code\ndemonstrates one such inconsistency:\n\n    h := http.Header{}\n    h[\"etag\"] = []string{\"1234\"}\n    h.Add(\"etag\", \"5678\")\n    fmt.Println(h)\n\n    // Output:\n    // map[Etag:[5678] etag:[1234]]\n\nThe easiest way of obtaining the canonical form of a key is to use\nhttp.CanonicalHeaderKey.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1008",
			"Default": true
		},
		{
			"Name": "SA1010",
			"Doc": "(*regexp.Regexp).FindAll called with n == 0, which will always return zero results\n\nIf n \u003e= 0, the function returns at most n matches/submatches. To\nreturn all results, specify a negative number.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1010",
			"Default": false
		},
		{
			"Name": "SA1011",
			"Doc": "Various methods in the 'strings' package expect valid UTF-8, but invalid input is provided\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1011",
			"Default": false
		},
		{
			"Name": "SA1012",
			"Doc": "A nil context.Context is being passed to a function, consider using context.TODO instead\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1012",
			"Default": true
		},
		{
			"Name": "SA1013",
			"Doc": "io.Seeker.Seek is being called with the whence constant as the first argument, but it should be the second\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1013",
			"Default": true
		},
		{
			"Name": "SA1014",
			"Doc": "Non-pointer value passed to Unmarshal or Decode\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1014",
			"Default": false
		},
		{
			"Name": "SA1015",
			"Doc": "Using time.Tick in a way that will leak. Consider using time.NewTicker, and only use time.Tick in tests, commands and endless functions\n\nBefore Go 1.23, time.Tickers had to be closed to be able to be garbage\ncollected. Since time.Tick doesn't make it possible to close the underlying\nticker, using it repeatedly would leak memory.\n\nGo 1.23 fixes this by allowing tickers to be collected even if they weren't closed.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1015",
			"Default": false
		},
		{
			"Name": "SA1016",
			"Doc": "Trapping a signal that cannot be trapped\n\nNot all signals can be intercepted by a process. Specifically, on\nUNIX-like systems, the syscall.SIGKILL and syscall.SIGSTOP signals are\nnever passed to the process, but instead handled directly by the\nkernel. It is therefore pointless to try and handle these signals.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1016",
			"Default": true
		},
		{
			"Name": "SA1017",
			"Doc": "Channels used with os/signal.Notify should be buffered\n\nThe os/signal package uses non-blocking channel sends when delivering\nsignals. If the receiving end of the channel isn't ready and the\nchannel is either unbuffered or full, the signal will be dropped. To\navoid missing signals, the channel should be buffered and of the\nappropriate size. For a channel used for notification of just one\nsignal value, a buffer of size 1 is sufficient.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1017",
			"Default": false
		},
		{
			"Name": "SA1018",
			"Doc": "strings.Replace called with n == 0, which does nothing\n\nWith n == 0, zero instances will be replaced. To replace all\ninstances, use a negative number, or use strings.ReplaceAll.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1018",
			"Default": false
		},
		{
			"Name": "SA1020",
			"Doc": "Using an invalid host:port pair with a net.Listen-related function\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1020",
			"Default": false
		},
		{
			"Name": "SA1021",
			"Doc": "Using bytes.Equal to compare two net.IP\n\nA net.IP stores an IPv4 or IPv6 address as a slice of bytes. The\nlength of the slice for an IPv4 address, however, can be either 4 or\n16 bytes long, using different ways of representing IPv4 addresses. In\norder to correctly compare two net.IPs, the net.IP.Equal method should\nbe used, as it takes both representations into account.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1021",
			"Default": false
		},
		{
			"Name": "SA1023",
			"Doc": "Modifying the buffer in an io.Writer implementation\n\nWrite must not modify the slice data, even temporarily.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1023",
			"Default": false
		},
		{
			"Name": "SA1024",
			"Doc": "A string cutset contains duplicate characters\n\nThe strings.TrimLeft and strings.TrimRight functions take cutsets, not\nprefixes. A cutset is treated as a set of characters to remove from a\nstring. For example,\n\n    strings.TrimLeft(\"42133word\", \"1234\")\n\nwill result in the string \"word\" – any characters that are 1, 2, 3 or\n4 are cut from the left of the string.\n\nIn order to remove one string from another, use strings.TrimPrefix instead.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1024",
			"Default": false
		},
		{
			"Name": "SA1025",
			"Doc": "It is not possible to use (*time.Timer).Reset's return value correctly\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1025",
			"Default": false
		},
		{
			"Name": "SA1026",
			"Doc": "Cannot marshal channels or functions\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1026",
			"Default": false
		},
		{
			"Name": "SA1027",
			"Doc": "Atomic access to 64-bit variable must be 64-bit aligned\n\nOn ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to\narrange for 64-bit alignment of 64-bit words accessed atomically. The\nfirst word in a variable or in an allocated struct, array, or slice\ncan be relied upon to be 64-bit aligned.\n\nYou can use the structlayout tool to inspect the alignment of fields\nin a struct.\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1027",
			"Default": false
		},
		{
			"Name": "SA1028",
			"Doc": "sort.Slice can only be used on slices\n\nThe first argument of sort.Slice must be a slice.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1028",
			"Default": false
		},
		{
			"Name": "SA1029",
			"Doc": "Inappropriate key in call to context.WithValue\n\nThe provided key must be comparable and should not be\nof type string or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys.\n\nTo avoid allocating when assigning to an interface{},\ncontext keys often have concrete type struct{}. Alternatively,\nexported context key variables' static type should be a pointer or\ninterface.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1029",
			"Default": false
		},
		{
			"Name": "SA1030",
			"Doc": "Invalid argument in call to a strconv function\n\nThis check validates the format, number base and bit size arguments of\nthe various parsing and formatting functions in strconv.\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1030",
			"Default": false
		},
		{
			"Name": "SA1031",
			"Doc": "Overlapping byte slices passed to an encoder\n\nIn an encoding function of the form Encode(dst, src), dst and\nsrc were found to reference the same memory. This can result in\nsrc bytes being overwritten before they are read, when the encoder\nwrites more than one byte per src byte.\n\nAvailable since\n    2024.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1031",
			"Default": false
		},
		{
			"Name": "SA1032",
			"Doc": "Wrong order of arguments to errors.Is\n\nThe first argument of the function errors.Is is the error\nthat we have and the second argument is the error we're trying to match against.\nFor example:\n\n\tif errors.Is(err, io.EOF) { ... }\n\nThis check detects some cases where the two arguments have been swapped. It\nflags any calls where the first argument is referring to a package-level error\nvariable, such as\n\n\tif errors.Is(io.EOF, err) { /* this is wrong */ }\n\nAvailable since\n    2024.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA1032",
			"Default": false
		},
		{
			"Name": "SA2001",
			"Doc": "Empty critical section, did you mean to defer the unlock?\n\nEmpty critical sections of the kind\n\n    mu.Lock()\n    mu.Unlock()\n\nare very often a typo, and the following was intended instead:\n\n    mu.Lock()\n    defer mu.Unlock()\n\nDo note that sometimes empty critical sections can be useful, as a\nform of signaling to wait on another goroutine. Many times, there are\nsimpler ways of achieving the same effect. When that isn't the case,\nthe code should be amply commented to avoid confusion. Combining such\ncomments with a //lint:ignore directive can be used to suppress this\nrare false positive.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA2001",
			"Default": true
		},
		{
			"Name": "SA2002",
			"Doc": "Called testing.T.FailNow or SkipNow in a goroutine, which isn't allowed\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA2002",
			"Default": false
		},
		{
			"Name": "SA2003",
			"Doc": "Deferred Lock right after locking, likely meant to defer Unlock instead\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA2003",
			"Default": false
		},
		{
			"Name": "SA3000",
			"Doc": "TestMain doesn't call os.Exit, hiding test failures\n\nTest executables (and in turn 'go test') exit with a non-zero status\ncode if any tests failed. When specifying your own TestMain function,\nit is your responsibility to arrange for this, by calling os.Exit with\nthe correct code. The correct code is returned by (*testing.M).Run, so\nthe usual way of implementing TestMain is to end it with\nos.Exit(m.Run()).\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA3000",
			"Default": true
		},
		{
			"Name": "SA3001",
			"Doc": "Assigning to b.N in benchmarks distorts the results\n\nThe testing package dynamically sets b.N to improve the reliability of\nbenchmarks and uses it in computations to determine the duration of a\nsingle operation. Benchmark code must not alter b.N as this would\nfalsify results.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA3001",
			"Default": true
		},
		{
			"Name": "SA4000",
			"Doc": "Binary operator has identical expressions on both sides\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4000",
			"Default": true
		},
		{
			"Name": "SA4001",
			"Doc": "\u0026*x gets simplified to x, it does not copy x\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4001",
			"Default": true
		},
		{
			"Name": "SA4003",
			"Doc": "Comparing unsigned values against negative values is pointless\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4003",
			"Default": true
		},
		{
			"Name": "SA4004",
			"Doc": "The loop exits unconditionally after one iteration\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4004",
			"Default": true
		},
		{
			"Name": "SA4005",
			"Doc": "Field assignment that will never be observed. Did you mean to use a pointer receiver?\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4005",
			"Default": false
		},
		{
			"Name": "SA4006",
			"Doc": "A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4006",
			"Default": false
		},
		{
			"Name": "SA4008",
			"Doc": "The variable in the loop condition never changes, are you incrementing the wrong variable?\n\nFor example:\n\n\tfor i := 0; i \u003c 10; j++ { ... }\n\nThis may also occur when a loop can only execute once because of unconditional\ncontrol flow that terminates the loop. For example, when a loop body contains an\nunconditional break, return, or panic:\n\n\tfunc f() {\n\t\tpanic(\"oops\")\n\t}\n\tfunc g() {\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\t// f unconditionally calls panic, which means \"i\" is\n\t\t\t// never incremented.\n\t\t\tf()\n\t\t}\n\t}\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4008",
			"Default": false
		},
		{
			"Name": "SA4009",
			"Doc": "A function argument is overwritten before its first use\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4009",
			"Default": false
		},
		{
			"Name": "SA4010",
			"Doc": "The result of append will never be observed anywhere\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4010",
			"Default": false
		},
		{
			"Name": "SA4011",
			"Doc": "Break statement with no effect. Did you mean to break out of an outer loop?\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4011",
			"Default": true
		},
		{
			"Name": "SA4012",
			"Doc": "Comparing a value against NaN even though no value is equal to NaN\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4012",
			"Default": false
		},
		{
			"Name": "SA4013",
			"Doc": "Negating a boolean twice (!!b) is the same as writing b. This is either redundant, or a typo.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4013",
			"Default": true
		},
		{
			"Name": "SA4014",
			"Doc": "An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4014",
			"Default": true
		},
		{
			"Name": "SA4015",
			"Doc": "Calling functions like math.Ceil on floats converted from integers doesn't do anything useful\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4015",
			"Default": false
		},
		{
			"Name": "SA4016",
			"Doc": "Certain bitwise operations, such as x ^ 0, do not do anything useful\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4016",
			"Default": true
		},
		{
			"Name": "SA4017",
			"Doc": "Discarding the return values of a function without side effects, making the call pointless\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4017",
			"Default": false
		},
		{
			"Name": "SA4018",
			"Doc": "Self-assignment of variables\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4018",
			"Default": false
		},
		{
			"Name": "SA4019",
			"Doc": "Multiple, identical build constraints in the same file\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4019",
			"Default": true
		},
		{
			"Name": "SA4020",
			"Doc": "Unreachable case clause in a type switch\n\nIn a type switch like the following\n\n    type T struct{}\n    func (T) Read(b []byte) (int, error) { return 0, nil }\n\n    var v any = T{}\n\n    switch v.(type) {\n    case io.Reader:\n        // ...\n    case T:\n        // unreachable\n    }\n\nthe second case clause can never be reached because T implements\nio.Reader and case clauses are evaluated in source order.\n\nAnother example:\n\n    type T struct{}\n    func (T) Read(b []byte) (int, error) { return 0, nil }\n    func (T) Close() error { return nil }\n\n    var v any = T{}\n\n    switch v.(type) {\n    case io.Reader:\n        // ...\n    case io.ReadCloser:\n        // unreachable\n    }\n\nEven though T has a Close method and thus implements io.ReadCloser,\nio.Reader will always match first. The method set of io.Reader is a\nsubset of io.ReadCloser. Thus it is impossible to match the second\ncase without matching the first case.\n\n\nStructurally equivalent interfaces\n\nA special case of the previous example are structurally identical\ninterfaces. Given these declarations\n\n    type T error\n    type V error\n\n    func doSomething() error {\n        err, ok := doAnotherThing()\n        if ok {\n            return T(err)\n        }\n\n        return U(err)\n    }\n\nthe following type switch will have an unreachable case clause:\n\n    switch doSomething().(type) {\n    case T:\n        // ...\n    case V:\n        // unreachable\n    }\n\nT will always match before V because they are structurally equivalent\nand therefore doSomething()'s return value implements both.\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4020",
			"Default": true
		},
		{
			"Name": "SA4022",
			"Doc": "Comparing the address of a variable against nil\n\nCode such as 'if \u0026x == nil' is meaningless, because taking the address of a variable always yields a non-nil pointer.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4022",
			"Default": true
		},
		{
			"Name": "SA4023",
			"Doc": "Impossible comparison of interface value with untyped nil\n\nUnder the covers, interfaces are implemented as two elements, a\ntype T and a value V. V is a concrete value such as an int,\nstruct or pointer, never an interface itself, and has type T. For\ninstance, if we store the int value 3 in an interface, the\nresulting interface value has, schematically, (T=int, V=3). The\nvalue V is also known as the interface's dynamic value, since a\ngiven interface variable might hold different values V (and\ncorresponding types T) during the execution of the program.\n\nAn interface value is nil only if the V and T are both\nunset, (T=nil, V is not set), In particular, a nil interface will\nalways hold a nil type. If we store a nil pointer of type *int\ninside an interface value, the inner type will be *int regardless\nof the value of the pointer: (T=*int, V=nil). Such an interface\nvalue will therefore be non-nil even when the pointer value V\ninside is nil.\n\nThis situation can be confusing, and arises when a nil value is\nstored inside an interface value such as an error return:\n\n    func returnsError() error {\n        var p *MyError = nil\n        if bad() {\n            p = ErrBad\n        }\n        return p // Will always return a non-nil error.\n    }\n\nIf all goes well, the function returns a nil p, so the return\nvalue is an error interface value holding (T=*MyError, V=nil).\nThis means that if the caller compares the returned error to nil,\nit will always look as if there was an error even if nothing bad\nhappened. To return a proper nil error to the caller, the\nfunction must return an explicit nil:\n\n    func returnsError() error {\n        if bad() {\n            return ErrBad\n        }\n        return nil\n    }\n\nIt's a good idea for functions that return errors always to use\nthe error type in their signature (as we did above) rather than a\nconcrete type such as *MyError, to help guarantee the error is\ncreated correctly. As an example, os.Open returns an error even\nthough, if not nil, it's always of concrete type *os.PathError.\n\nSimilar situations to those described here can arise whenever\ninterfaces are used. Just keep in mind that if any concrete value\nhas been stored in the interface, the interface will not be nil.\nFor more information, see The Laws of\nReflection at https://golang.org/doc/articles/laws_of_reflection.html.\n\nThis text has been copied from\nhttps://golang.org/doc/faq#nil_error, licensed under the Creative\nCommons Attribution 3.0 License.\n\nAvailable since\n    2020.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4023",
			"Default": false
		},
		{
			"Name": "SA4024",
			"Doc": "Checking for impossible return value from a builtin function\n\nReturn values of the len and cap builtins cannot be negative.\n\nSee https://golang.org/pkg/builtin/#len and https://golang.org/pkg/builtin/#cap.\n\nExample:\n\n    if len(slice) \u003c 0 {\n        fmt.Println(\"unreachable code\")\n    }\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4024",
			"Default": true
		},
		{
			"Name": "SA4025",
			"Doc": "Integer division of literals that results in zero\n\nWhen dividing two integer constants, the result will\nalso be an integer. Thus, a division such as 2 / 3 results in 0.\nThis is true for all of the following examples:\n\n\t_ = 2 / 3\n\tconst _ = 2 / 3\n\tconst _ float64 = 2 / 3\n\t_ = float64(2 / 3)\n\nStaticcheck will flag such divisions if both sides of the division are\ninteger literals, as it is highly unlikely that the division was\nintended to truncate to zero. Staticcheck will not flag integer\ndivision involving named constants, to avoid noisy positives.\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4025",
			"Default": true
		},
		{
			"Name": "SA4026",
			"Doc": "Go constants cannot express negative zero\n\nIn IEEE 754 floating point math, zero has a sign and can be positive\nor negative. This can be useful in certain numerical code.\n\nGo constants, however, cannot express negative zero. This means that\nthe literals -0.0 and 0.0 have the same ideal value (zero) and\nwill both represent positive zero at runtime.\n\nTo explicitly and reliably create a negative zero, you can use the\nmath.Copysign function: math.Copysign(0, -1).\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4026",
			"Default": true
		},
		{
			"Name": "SA4027",
			"Doc": "(*net/url.URL).Query returns a copy, modifying it doesn't change the URL\n\n(*net/url.URL).Query parses the current value of net/url.URL.RawQuery\nand returns it as a map of type net/url.Values. Subsequent changes to\nthis map will not affect the URL unless the map gets encoded and\nassigned to the URL's RawQuery.\n\nAs a consequence, the following code pattern is an expensive no-op:\nu.Query().Add(key, value).\n\nAvailable since\n    2021.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4027",
			"Default": true
		},
		{
			"Name": "SA4028",
			"Doc": "x % 1 is always zero\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4028",
			"Default": true
		},
		{
			"Name": "SA4029",
			"Doc": "Ineffective attempt at sorting slice\n\nsort.Float64Slice, sort.IntSlice, and sort.StringSlice are\ntypes, not functions. Doing x = sort.StringSlice(x) does nothing,\nespecially not sort any values. The correct usage is\nsort.Sort(sort.StringSlice(x)) or sort.StringSlice(x).Sort(),\nbut there are more convenient helpers, namely sort.Float64s,\nsort.Ints, and sort.Strings.\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4029",
			"Default": true
		},
		{
			"Name": "SA4030",
			"Doc": "Ineffective attempt at generating random number\n\nFunctions in the math/rand package that accept upper limits, such\nas Intn, generate random numbers in the half-open interval [0,n). In\nother words, the generated numbers will be \u003e= 0 and \u003c n – they\ndon't include n. rand.Intn(1) therefore doesn't generate 0\nor 1, it always generates 0.\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4030",
			"Default": true
		},
		{
			"Name": "SA4031",
			"Doc": "Checking never-nil value against nil\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4031",
			"Default": false
		},
		{
			"Name": "SA4032",
			"Doc": "Comparing runtime.GOOS or runtime.GOARCH against impossible value\n\nAvailable since\n    2024.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA4032",
			"Default": true
		},
		{
			"Name": "SA5000",
			"Doc": "Assignment to nil map\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5000",
			"Default": false
		},
		{
			"Name": "SA5001",
			"Doc": "Deferring Close before checking for a possible error\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5001",
			"Default": true
		},
		{
			"Name": "SA5002",
			"Doc": "The empty for loop ('for {}') spins and can block the scheduler\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5002",
			"Default": false
		},
		{
			"Name": "SA5003",
			"Doc": "Defers in infinite loops will never execute\n\nDefers are scoped to the surrounding function, not the surrounding\nblock. In a function that never returns, i.e. one containing an\ninfinite loop, defers will never execute.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5003",
			"Default": true
		},
		{
			"Name": "SA5004",
			"Doc": "'for { select { ...' with an empty default branch spins\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5004",
			"Default": true
		},
		{
			"Name": "SA5005",
			"Doc": "The finalizer references the finalized object, preventing garbage collection\n\nA finalizer is a function associated with an object that runs when the\ngarbage collector is ready to collect said object, that is when the\nobject is no longer referenced by anything.\n\nIf the finalizer references the object, however, it will always remain\nas the final reference to that object, preventing the garbage\ncollector from collecting the object. The finalizer will never run,\nand the object will never be collected, leading to a memory leak. That\nis why the finalizer should instead use its first argument to operate\non the object. That way, the number of references can temporarily go\nto zero before the object is being passed to the finalizer.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5005",
			"Default": false
		},
		{
			"Name": "SA5007",
			"Doc": "Infinite recursive call\n\nA function that calls itself recursively needs to have an exit\ncondition. Otherwise it will recurse forever, until the system runs\nout of memory.\n\nThis issue can be caused by simple bugs such as forgetting to add an\nexit condition. It can also happen \"on purpose\". Some languages have\ntail call optimization which makes certain infinite recursive calls\nsafe to use. Go, however, does not implement TCO, and as such a loop\nshould be used instead.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5007",
			"Default": false
		},
		{
			"Name": "SA5008",
			"Doc": "Invalid struct tag\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5008",
			"Default": true
		},
		{
			"Name": "SA5010",
			"Doc": "Impossible type assertion\n\nSome type assertions can be statically proven to be\nimpossible. This is the case when the method sets of both\narguments of the type assertion conflict with each other, for\nexample by containing the same method with different\nsignatures.\n\nThe Go compiler already applies this check when asserting from an\ninterface value to a concrete type. If the concrete type misses\nmethods from the interface, or if function signatures don't match,\nthen the type assertion can never succeed.\n\nThis check applies the same logic when asserting from one interface to\nanother. If both interface types contain the same method but with\ndifferent signatures, then the type assertion can never succeed,\neither.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5010",
			"Default": false
		},
		{
			"Name": "SA5011",
			"Doc": "Possible nil pointer dereference\n\nA pointer is being dereferenced unconditionally, while\nalso being checked against nil in another place. This suggests that\nthe pointer may be nil and dereferencing it may panic. This is\ncommonly a result of improperly ordered code or missing return\nstatements. Consider the following examples:\n\n    func fn(x *int) {\n        fmt.Println(*x)\n\n        // This nil check is equally important for the previous dereference\n        if x != nil {\n            foo(*x)\n        }\n    }\n\n    func TestFoo(t *testing.T) {\n        x := compute()\n        if x == nil {\n            t.Errorf(\"nil pointer received\")\n        }\n\n        // t.Errorf does not abort the test, so if x is nil, the next line will panic.\n        foo(*x)\n    }\n\nStaticcheck tries to deduce which functions abort control flow.\nFor example, it is aware that a function will not continue\nexecution after a call to panic or log.Fatal. However, sometimes\nthis detection fails, in particular in the presence of\nconditionals. Consider the following example:\n\n    func Log(msg string, level int) {\n        fmt.Println(msg)\n        if level == levelFatal {\n            os.Exit(1)\n        }\n    }\n\n    func Fatal(msg string) {\n        Log(msg, levelFatal)\n    }\n\n    func fn(x *int) {\n        if x == nil {\n            Fatal(\"unexpected nil pointer\")\n        }\n        fmt.Println(*x)\n    }\n\nStaticcheck will flag the dereference of x, even though it is perfectly\nsafe. Staticcheck is not able to deduce that a call to\nFatal will exit the program. For the time being, the easiest\nworkaround is to modify the definition of Fatal like so:\n\n    func Fatal(msg string) {\n        Log(msg, levelFatal)\n        panic(\"unreachable\")\n    }\n\nWe also hard-code functions from common logging packages such as\nlogrus. Please file an issue if we're missing support for a\npopular package.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5011",
			"Default": false
		},
		{
			"Name": "SA5012",
			"Doc": "Passing odd-sized slice to function expecting even size\n\nSome functions that take slices as parameters expect the slices to have an even number of elements. \nOften, these functions treat elements in a slice as pairs. \nFor example, strings.NewReplacer takes pairs of old and new strings, \nand calling it with an odd number of elements would be an error.\n\nAvailable since\n    2020.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA5012",
			"Default": false
		},
		{
			"Name": "SA6000",
			"Doc": "Using regexp.Match or related in a loop, should use regexp.Compile\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA6000",
			"Default": false
		},
		{
			"Name": "SA6001",
			"Doc": "Missing an optimization opportunity when indexing maps by byte slices\n\nMap keys must be comparable, which precludes the use of byte slices.\nThis usually leads to using string keys and converting byte slices to\nstrings.\n\nNormally, a conversion of a byte slice to a string needs to copy the data and\ncauses allocations. The compiler, however, recognizes m[string(b)] and\nuses the data of b directly, without copying it, because it knows that\nthe data can't change during the map lookup. This leads to the\ncounter-intuitive situation that\n\n    k := string(b)\n    println(m[k])\n    println(m[k])\n\nwill be less efficient than\n\n    println(m[string(b)])\n    println(m[string(b)])\n\nbecause the first version needs to copy and allocate, while the second\none does not.\n\nFor some history on this optimization, check out commit\nf5f5a8b6209f84961687d993b93ea0d397f5d5bf in the Go repository.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA6001",
			"Default": false
		},
		{
			"Name": "SA6002",
			"Doc": "Storing non-pointer values in sync.Pool allocates memory\n\nA sync.Pool is used to avoid unnecessary allocations and reduce the\namount of work the garbage collector has to do.\n\nWhen passing a value that is not a pointer to a function that accepts\nan interface, the value needs to be placed on the heap, which means an\nadditional allocation. Slices are a common thing to put in sync.Pools,\nand they're structs with 3 fields (length, capacity, and a pointer to\nan array). In order to avoid the extra allocation, one should store a\npointer to the slice instead.\n\nSee the comments on https://go-review.googlesource.com/c/go/+/24371\nthat discuss this problem.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA6002",
			"Default": false
		},
		{
			"Name": "SA6003",
			"Doc": "Converting a string to a slice of runes before ranging over it\n\nYou may want to loop over the runes in a string. Instead of converting\nthe string to a slice of runes and looping over that, you can loop\nover the string itself. That is,\n\n    for _, r := range s {}\n\nand\n\n    for _, r := range []rune(s) {}\n\nwill yield the same values. The first version, however, will be faster\nand avoid unnecessary memory allocations.\n\nDo note that if you are interested in the indices, ranging over a\nstring and over a slice of runes will yield different indices. The\nfirst one yields byte offsets, while the second one yields indices in\nthe slice of runes.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA6003",
			"Default": false
		},
		{
			"Name": "SA6005",
			"Doc": "Inefficient string comparison with strings.ToLower or strings.ToUpper\n\nConverting two strings to the same case and comparing them like so\n\n    if strings.ToLower(s1) == strings.ToLower(s2) {\n        ...\n    }\n\nis significantly more expensive than comparing them with\nstrings.EqualFold(s1, s2). This is due to memory usage as well as\ncomputational complexity.\n\nstrings.ToLower will have to allocate memory for the new strings, as\nwell as convert both strings fully, even if they differ on the very\nfirst byte. strings.EqualFold, on the other hand, compares the strings\none character at a time. It doesn't need to create two intermediate\nstrings and can return as soon as the first non-matching character has\nbeen found.\n\nFor a more in-depth explanation of this issue, see\nhttps://blog.digitalocean.com/how-to-efficiently-compare-strings-in-go/\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA6005",
			"Default": true
		},
		{
			"Name": "SA6006",
			"Doc": "Using io.WriteString to write []byte\n\nUsing io.WriteString to write a slice of bytes, as in\n\n    io.WriteString(w, string(b))\n\nis both unnecessary and inefficient. Converting from []byte to string\nhas to allocate and copy the data, and we could simply use w.Write(b)\ninstead.\n\nAvailable since\n    2024.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA6006",
			"Default": true
		},
		{
			"Name": "SA9001",
			"Doc": "Defers in range loops may not run when you expect them to\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9001",
			"Default": false
		},
		{
			"Name": "SA9002",
			"Doc": "Using a non-octal os.FileMode that looks like it was meant to be in octal.\n\nAvailable since\n    2017.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9002",
			"Default": true
		},
		{
			"Name": "SA9003",
			"Doc": "Empty body in an if or else branch\n\nAvailable since\n    2017.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9003",
			"Default": false
		},
		{
			"Name": "SA9004",
			"Doc": "Only the first constant has an explicit type\n\nIn a constant declaration such as the following:\n\n    const (\n        First byte = 1\n        Second     = 2\n    )\n\nthe constant Second does not have the same type as the constant First.\nThis construct shouldn't be confused with\n\n    const (\n        First byte = iota\n        Second\n    )\n\nwhere First and Second do indeed have the same type. The type is only\npassed on when no explicit value is assigned to the constant.\n\nWhen declaring enumerations with explicit values it is therefore\nimportant not to write\n\n    const (\n          EnumFirst EnumType = 1\n          EnumSecond         = 2\n          EnumThird          = 3\n    )\n\nThis discrepancy in types can cause various confusing behaviors and\nbugs.\n\n\nWrong type in variable declarations\n\nThe most obvious issue with such incorrect enumerations expresses\nitself as a compile error:\n\n    package pkg\n\n    const (\n        EnumFirst  uint8 = 1\n        EnumSecond       = 2\n    )\n\n    func fn(useFirst bool) {\n        x := EnumSecond\n        if useFirst {\n            x = EnumFirst\n        }\n    }\n\nfails to compile with\n\n    ./const.go:11:5: cannot use EnumFirst (type uint8) as type int in assignment\n\n\nLosing method sets\n\nA more subtle issue occurs with types that have methods and optional\ninterfaces. Consider the following:\n\n    package main\n\n    import \"fmt\"\n\n    type Enum int\n\n    func (e Enum) String() string {\n        return \"an enum\"\n    }\n\n    const (\n        EnumFirst  Enum = 1\n        EnumSecond      = 2\n    )\n\n    func main() {\n        fmt.Println(EnumFirst)\n        fmt.Println(EnumSecond)\n    }\n\nThis code will output\n\n    an enum\n    2\n\nas EnumSecond has no explicit type, and thus defaults to int.\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9004",
			"Default": true
		},
		{
			"Name": "SA9005",
			"Doc": "Trying to marshal a struct with no public fields nor custom marshaling\n\nThe encoding/json and encoding/xml packages only operate on exported\nfields in structs, not unexported ones. It is usually an error to try\nto (un)marshal structs that only consist of unexported fields.\n\nThis check will not flag calls involving types that define custom\nmarshaling behavior, e.g. via MarshalJSON methods. It will also not\nflag empty structs.\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9005",
			"Default": false
		},
		{
			"Name": "SA9006",
			"Doc": "Dubious bit shifting of a fixed size integer value\n\nBit shifting a value past its size will always clear the value.\n\nFor instance:\n\n    v := int8(42)\n    v \u003e\u003e= 8\n\nwill always result in 0.\n\nThis check flags bit shifting operations on fixed size integer values only.\nThat is, int, uint and uintptr are never flagged to avoid potential false\npositives in somewhat exotic but valid bit twiddling tricks:\n\n    // Clear any value above 32 bits if integers are more than 32 bits.\n    func f(i int) int {\n        v := i \u003e\u003e 32\n        v = v \u003c\u003c 32\n        return i-v\n    }\n\nAvailable since\n    2020.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9006",
			"Default": true
		},
		{
			"Name": "SA9007",
			"Doc": "Deleting a directory that shouldn't be deleted\n\nIt is virtually never correct to delete system directories such as\n/tmp or the user's home directory. However, it can be fairly easy to\ndo by mistake, for example by mistakenly using os.TempDir instead\nof ioutil.TempDir, or by forgetting to add a suffix to the result\nof os.UserHomeDir.\n\nWriting\n\n    d := os.TempDir()\n    defer os.RemoveAll(d)\n\nin your unit tests will have a devastating effect on the stability of your system.\n\nThis check flags attempts at deleting the following directories:\n\n- os.TempDir\n- os.UserCacheDir\n- os.UserConfigDir\n- os.UserHomeDir\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9007",
			"Default": false
		},
		{
			"Name": "SA9008",
			"Doc": "else branch of a type assertion is probably not reading the right value\n\nWhen declaring variables as part of an if statement (like in 'if\nfoo := ...; foo {'), the same variables will also be in the scope of\nthe else branch. This means that in the following example\n\n    if x, ok := x.(int); ok {\n        // ...\n    } else {\n        fmt.Printf(\"unexpected type %T\", x)\n    }\n\nx in the else branch will refer to the x from x, ok\n:=; it will not refer to the x that is being type-asserted. The\nresult of a failed type assertion is the zero value of the type that\nis being asserted to, so x in the else branch will always have the\nvalue 0 and the type int.\n\nAvailable since\n    2022.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9008",
			"Default": false
		},
		{
			"Name": "SA9009",
			"Doc": "Ineffectual Go compiler directive\n\nA potential Go compiler directive was found, but is ineffectual as it begins\nwith whitespace.\n\nAvailable since\n    2024.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#SA9009",
			"Default": true
		},
		{
			"Name": "ST1000",
			"Doc": "Incorrect or missing package comment\n\nPackages must have a package comment that is formatted according to\nthe guidelines laid out in\nhttps://go.dev/wiki/CodeReviewComments#package-comments.\n\nAvailable since\n    2019.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1000",
			"Default": false
		},
		{
			"Name": "ST1001",
			"Doc": "Dot imports are discouraged\n\nDot imports that aren't in external test packages are discouraged.\n\nThe dot_import_whitelist option can be used to whitelist certain\nimports.\n\nQuoting Go Code Review Comments:\n\n\u003e The import . form can be useful in tests that, due to circular\n\u003e dependencies, cannot be made part of the package being tested:\n\u003e \n\u003e     package foo_test\n\u003e \n\u003e     import (\n\u003e         \"bar/testutil\" // also imports \"foo\"\n\u003e         . \"foo\"\n\u003e     )\n\u003e \n\u003e In this case, the test file cannot be in package foo because it\n\u003e uses bar/testutil, which imports foo. So we use the import .\n\u003e form to let the file pretend to be part of package foo even though\n\u003e it is not. Except for this one case, do not use import . in your\n\u003e programs. It makes the programs much harder to read because it is\n\u003e unclear whether a name like Quux is a top-level identifier in the\n\u003e current package or in an imported package.\n\nAvailable since\n    2019.1\n\nOptions\n    dot_import_whitelist\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1001",
			"Default": false
		},
		{
			"Name": "ST1003",
			"Doc": "Poorly chosen identifier\n\nIdentifiers, such as variable and package names, follow certain rules.\n\nSee the following links for details:\n\n- https://go.dev/doc/effective_go#package-names\n- https://go.dev/doc/effective_go#mixed-caps\n- https://go.dev/wiki/CodeReviewComments#initialisms\n- https://go.dev/wiki/CodeReviewComments#variable-names\n\nAvailable since\n    2019.1, non-default\n\nOptions\n    initialisms\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1003",
			"Default": false
		},
		{
			"Name": "ST1005",
			"Doc": "Incorrectly formatted error string\n\nError strings follow a set of guidelines to ensure uniformity and good\ncomposability.\n\nQuoting Go Code Review Comments:\n\n\u003e Error strings should not be capitalized (unless beginning with\n\u003e proper nouns or acronyms) or end with punctuation, since they are\n\u003e usually printed following other context. That is, use\n\u003e fmt.Errorf(\"something bad\") not fmt.Errorf(\"Something bad\"), so\n\u003e that log.Printf(\"Reading %s: %v\", filename, err) formats without a\n\u003e spurious capital letter mid-message.\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1005",
			"Default": false
		},
		{
			"Name": "ST1006",
			"Doc": "Poorly chosen receiver name\n\nQuoting Go Code Review Comments:\n\n\u003e The name of a method's receiver should be a reflection of its\n\u003e identity; often a one or two letter abbreviation of its type\n\u003e suffices (such as \"c\" or \"cl\" for \"Client\"). Don't use generic\n\u003e names such as \"me\", \"this\" or \"self\", identifiers typical of\n\u003e object-oriented languages that place more emphasis on methods as\n\u003e opposed to functions. The name need not be as descriptive as that\n\u003e of a method argument, as its role is obvious and serves no\n\u003e documentary purpose. It can be very short as it will appear on\n\u003e almost every line of every method of the type; familiarity admits\n\u003e brevity. Be consistent, too: if you call the receiver \"c\" in one\n\u003e method, don't call it \"cl\" in another.\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1006",
			"Default": false
		},
		{
			"Name": "ST1008",
			"Doc": "A function's error value should be its last return value\n\nA function's error value should be its last return value.\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1008",
			"Default": false
		},
		{
			"Name": "ST1011",
			"Doc": "Poorly chosen name for variable of type time.Duration\n\ntime.Duration values represent an amount of time, which is represented\nas a count of nanoseconds. An expression like 5 * time.Microsecond\nyields the value 5000. It is therefore not appropriate to suffix a\nvariable of type time.Duration with any time unit, such as Msec or\nMilli.\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1011",
			"Default": false
		},
		{
			"Name": "ST1012",
			"Doc": "Poorly chosen name for error variable\n\nError variables that are part of an API should be called errFoo or\nErrFoo.\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1012",
			"Default": false
		},
		{
			"Name": "ST1013",
			"Doc": "Should use constants for HTTP error codes, not magic numbers\n\nHTTP has a tremendous number of status codes. While some of those are\nwell known (200, 400, 404, 500), most of them are not. The net/http\npackage provides constants for all status codes that are part of the\nvarious specifications. It is recommended to use these constants\ninstead of hard-coding magic numbers, to vastly improve the\nreadability of your code.\n\nAvailable since\n    2019.1\n\nOptions\n    http_status_code_whitelist\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1013",
			"Default": false
		},
		{
			"Name": "ST1015",
			"Doc": "A switch's default case should be the first or last case\n\nAvailable since\n    2019.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1015",
			"Default": false
		},
		{
			"Name": "ST1016",
			"Doc": "Use consistent method receiver names\n\nAvailable since\n    2019.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1016",
			"Default": false
		},
		{
			"Name": "ST1017",
			"Doc": "Don't use Yoda conditions\n\nYoda conditions are conditions of the kind 'if 42 == x', where the\nliteral is on the left side of the comparison. These are a common\nidiom in languages in which assignment is an expression, to avoid bugs\nof the kind 'if (x = 42)'. In Go, which doesn't allow for this kind of\nbug, we prefer the more idiomatic 'if x == 42'.\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1017",
			"Default": false
		},
		{
			"Name": "ST1018",
			"Doc": "Avoid zero-width and control characters in string literals\n\nAvailable since\n    2019.2\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1018",
			"Default": false
		},
		{
			"Name": "ST1019",
			"Doc": "Importing the same package multiple times\n\nGo allows importing the same package multiple times, as long as\ndifferent import aliases are being used. That is, the following\nbit of code is valid:\n\n    import (\n        \"fmt\"\n        fumpt \"fmt\"\n        format \"fmt\"\n        _ \"fmt\"\n    )\n\nHowever, this is very rarely done on purpose. Usually, it is a\nsign of code that got refactored, accidentally adding duplicate\nimport statements. It is also a rarely known feature, which may\ncontribute to confusion.\n\nDo note that sometimes, this feature may be used\nintentionally (see for example\nhttps://github.com/golang/go/commit/3409ce39bfd7584523b7a8c150a310cea92d879d)\n– if you want to allow this pattern in your code base, you're\nadvised to disable this check.\n\nAvailable since\n    2020.1\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1019",
			"Default": false
		},
		{
			"Name": "ST1020",
			"Doc": "The documentation of an exported function should start with the function's name\n\nDoc comments work best as complete sentences, which\nallow a wide variety of automated presentations. The first sentence\nshould be a one-sentence summary that starts with the name being\ndeclared.\n\nIf every doc comment begins with the name of the item it describes,\nyou can use the doc subcommand of the go tool and run the output\nthrough grep.\n\nSee https://go.dev/doc/effective_go#commentary for more\ninformation on how to write good documentation.\n\nAvailable since\n    2020.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1020",
			"Default": false
		},
		{
			"Name": "ST1021",
			"Doc": "The documentation of an exported type should start with type's name\n\nDoc comments work best as complete sentences, which\nallow a wide variety of automated presentations. The first sentence\nshould be a one-sentence summary that starts with the name being\ndeclared.\n\nIf every doc comment begins with the name of the item it describes,\nyou can use the doc subcommand of the go tool and run the output\nthrough grep.\n\nSee https://go.dev/doc/effective_go#commentary for more\ninformation on how to write good documentation.\n\nAvailable since\n    2020.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1021",
			"Default": false
		},
		{
			"Name": "ST1022",
			"Doc": "The documentation of an exported variable or constant should start with variable's name\n\nDoc comments work best as complete sentences, which\nallow a wide variety of automated presentations. The first sentence\nshould be a one-sentence summary that starts with the name being\ndeclared.\n\nIf every doc comment begins with the name of the item it describes,\nyou can use the doc subcommand of the go tool and run the output\nthrough grep.\n\nSee https://go.dev/doc/effective_go#commentary for more\ninformation on how to write good documentation.\n\nAvailable since\n    2020.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#ST1022",
			"Default": false
		},
		{
			"Name": "ST1023",
			"Doc": "Redundant type in variable declaration\n\nAvailable since\n    2021.1, non-default\n",
			"URL": "https://staticcheck.dev/docs/checks/#",
			"Default": false
		},
		{
			"Name": "any",
			"Doc": "replace interface{} with any\n\nThe any analyzer suggests replacing uses of the empty interface type,\n`interface{}`, with the `any` alias, which was introduced in Go 1.18.\nThis is a purely stylistic change that makes code more readable.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#any",
			"Default": true
		},
		{
			"Name": "appendclipped",
			"Doc": "simplify append chains using slices.Concat\n\nThe appendclipped analyzer suggests replacing chains of append calls with a\nsingle call to slices.Concat, which was added in Go 1.21. For example,\nappend(append(s, s1...), s2...) would be simplified to slices.Concat(s, s1, s2).\n\nIn the simple case of appending to a newly allocated slice, such as\nappend([]T(nil), s...), the analyzer suggests the more concise slices.Clone(s).\nFor byte slices, it will prefer bytes.Clone if the \"bytes\" package is\nalready imported.\n\nThis fix is only applied when the base of the append tower is a\n\"clipped\" slice, meaning its length and capacity are equal (e.g.\nx[:0:0] or []T{}). This is to avoid changing program behavior by\neliminating intended side effects on the base slice's underlying\narray.\n\nThis analyzer is currently disabled by default as the\ntransformation does not preserve the nilness of the base slice in\nall cases; see https://go.dev/issue/73557.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#appendclipped",
			"Default": false
		},
		{
			"Name": "appends",
			"Doc": "check for missing values after append\n\nThis checker reports calls to append that pass\nno values to be appended to the slice.\n\n\ts := []string{\"a\", \"b\", \"c\"}\n\t_ = append(s)\n\nSuch calls are always no-ops and often indicate an\nunderlying mistake.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/appends",
			"Default": true
		},
		{
			"Name": "asmdecl",
			"Doc": "report mismatches between assembly files and Go declarations",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/asmdecl",
			"Default": true
		},
		{
			"Name": "assign",
			"Doc": "check for useless assignments\n\nThis checker reports assignments of the form x = x or a[i] = a[i].\nThese are almost always useless, and even when they aren't they are\nusually a mistake.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/assign",
			"Default": true
		},
		{
			"Name": "atomic",
			"Doc": "check for common mistakes using the sync/atomic package\n\nThe atomic checker looks for assignment statements of the form:\n\n\tx = atomic.AddUint64(\u0026x, 1)\n\nwhich are not atomic.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/atomic",
			"Default": true
		},
		{
			"Name": "atomicalign",
			"Doc": "check for non-64-bits-aligned arguments to sync/atomic functions",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/atomicalign",
			"Default": true
		},
		{
			"Name": "bloop",
			"Doc": "replace for-range over b.N with b.Loop\n\nThe bloop analyzer suggests replacing benchmark loops of the form\n`for i := 0; i \u003c b.N; i++` or `for range b.N` with the more modern\n`for b.Loop()`, which was added in Go 1.24.\n\nThis change makes benchmark code more readable and also removes the need for\nmanual timer control, so any preceding calls to b.StartTimer, b.StopTimer,\nor b.ResetTimer within the same function will also be removed.\n\nCaveats: The b.Loop() method is designed to prevent the compiler from\noptimizing away the benchmark loop, which can occasionally result in\nslower execution due to increased allocations in some specific cases.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#bloop",
			"Default": true
		},
		{
			"Name": "bools",
			"Doc": "check for common mistakes involving boolean operators",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/bools",
			"Default": true
		},
		{
			"Name": "buildtag",
			"Doc": "check //go:build and // +build directives",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/buildtag",
			"Default": true
		},
		{
			"Name": "cgocall",
			"Doc": "detect some violations of the cgo pointer passing rules\n\nCheck for invalid cgo pointer passing.\nThis looks for code that uses cgo to call C code passing values\nwhose types are almost always invalid according to the cgo pointer\nsharing rules.\nSpecifically, it warns about attempts to pass a Go chan, map, func,\nor slice to C, either directly, or via a pointer, array, or struct.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/cgocall",
			"Default": true
		},
		{
			"Name": "composites",
			"Doc": "check for unkeyed composite literals\n\nThis analyzer reports a diagnostic for composite literals of struct\ntypes imported from another package that do not use the field-keyed\nsyntax. Such literals are fragile because the addition of a new field\n(even if unexported) to the struct will cause compilation to fail.\n\nAs an example,\n\n\terr = \u0026net.DNSConfigError{err}\n\nshould be replaced by:\n\n\terr = \u0026net.DNSConfigError{Err: err}\n",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/composite",
			"Default": true
		},
		{
			"Name": "copylocks",
			"Doc": "check for locks erroneously passed by value\n\nInadvertently copying a value containing a lock, such as sync.Mutex or\nsync.WaitGroup, may cause both copies to malfunction. Generally such\nvalues should be referred to through a pointer.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/copylock",
			"Default": true
		},
		{
			"Name": "deepequalerrors",
			"Doc": "check for calls of reflect.DeepEqual on error values\n\nThe deepequalerrors checker looks for calls of the form:\n\n    reflect.DeepEqual(err1, err2)\n\nwhere err1 and err2 are errors. Using reflect.DeepEqual to compare\nerrors is discouraged.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/deepequalerrors",
			"Default": true
		},
		{
			"Name": "defers",
			"Doc": "report common mistakes in defer statements\n\nThe defers analyzer reports a diagnostic when a defer statement would\nresult in a non-deferred call to time.Since, as experience has shown\nthat this is nearly always a mistake.\n\nFor example:\n\n\tstart := time.Now()\n\t...\n\tdefer recordLatency(time.Since(start)) // error: call to time.Since is not deferred\n\nThe correct code is:\n\n\tdefer func() { recordLatency(time.Since(start)) }()",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/defers",
			"Default": true
		},
		{
			"Name": "deprecated",
			"Doc": "check for use of deprecated identifiers\n\nThe deprecated analyzer looks for deprecated symbols and package\nimports.\n\nSee https://go.dev/wiki/Deprecated to learn about Go's convention\nfor documenting and signaling deprecated identifiers.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated",
			"Default": true
		},
		{
			"Name": "directive",
			"Doc": "check Go toolchain directives such as //go:debug\n\nThis analyzer checks for problems with known Go toolchain directives\nin all Go source files in a package directory, even those excluded by\n//go:build constraints, and all non-Go source files too.\n\nFor //go:debug (see https://go.dev/doc/godebug), the analyzer checks\nthat the directives are placed only in Go source files, only above the\npackage comment, and only in package main or *_test.go files.\n\nSupport for other known directives may be added in the future.\n\nThis analyzer does not check //go:build, which is handled by the\nbuildtag analyzer.\n",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/directive",
			"Default": true
		},
		{
			"Name": "embed",
			"Doc": "check //go:embed directive usage\n\nThis analyzer checks that the embed package is imported if //go:embed\ndirectives are present, providing a suggested fix to add the import if\nit is missing.\n\nThis analyzer also checks that //go:embed directives precede the\ndeclaration of a single variable.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/embeddirective",
			"Default": true
		},
		{
			"Name": "errorsas",
			"Doc": "report passing non-pointer or non-error values to errors.As\n\nThe errorsas analyzer reports calls to errors.As where the type\nof the second argument is not a pointer to a type implementing error.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/errorsas",
			"Default": true
		},
		{
			"Name": "errorsastype",
			"Doc": "replace errors.As with errors.AsType[T]\n\nThis analyzer suggests fixes to simplify uses of [errors.As] of\nthis form:\n\n\tvar myerr *MyErr\n\tif errors.As(err, \u0026myerr) {\n\t\thandle(myerr)\n\t}\n\nby using the less error-prone generic [errors.AsType] function,\nintroduced in Go 1.26:\n\n\tif myerr, ok := errors.AsType[*MyErr](err); ok {\n\t\thandle(myerr)\n\t}\n\nThe fix is only offered if the var declaration has the form shown and\nthere are no uses of myerr outside the if statement.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#errorsastype",
			"Default": true
		},
		{
			"Name": "fillreturns",
			"Doc": "suggest fixes for errors due to an incorrect number of return values\n\nThis checker provides suggested fixes for type errors of the\ntype \"wrong number of return values (want %d, got %d)\". For example:\n\n\tfunc m() (int, string, *bool, error) {\n\t\treturn\n\t}\n\nwill turn into\n\n\tfunc m() (int, string, *bool, error) {\n\t\treturn 0, \"\", nil, nil\n\t}\n\nThis functionality is similar to https://github.com/sqs/goreturns.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/fillreturns",
			"Default": true
		},
		{
			"Name": "fmtappendf",
			"Doc": "replace []byte(fmt.Sprintf) with fmt.Appendf\n\nThe fmtappendf analyzer suggests replacing `[]byte(fmt.Sprintf(...))` with\n`fmt.Appendf(nil, ...)`. This avoids the intermediate allocation of a string\nby Sprintf, making the code more efficient. The suggestion also applies to\nfmt.Sprint and fmt.Sprintln.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#fmtappendf",
			"Default": true
		},
		{
			"Name": "forvar",
			"Doc": "remove redundant re-declaration of loop variables\n\nThe forvar analyzer removes unnecessary shadowing of loop variables.\nBefore Go 1.22, it was common to write `for _, x := range s { x := x ... }`\nto create a fresh variable for each iteration. Go 1.22 changed the semantics\nof `for` loops, making this pattern redundant. This analyzer removes the\nunnecessary `x := x` statement.\n\nThis fix only applies to `range` loops.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#forvar",
			"Default": true
		},
		{
			"Name": "framepointer",
			"Doc": "report assembly that clobbers the frame pointer before saving it",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/framepointer",
			"Default": true
		},
		{
			"Name": "hostport",
			"Doc": "check format of addresses passed to net.Dial\n\nThis analyzer flags code that produce network address strings using\nfmt.Sprintf, as in this example:\n\n    addr := fmt.Sprintf(\"%s:%d\", host, 12345) // \"will not work with IPv6\"\n    ...\n    conn, err := net.Dial(\"tcp\", addr)       // \"when passed to dial here\"\n\nThe analyzer suggests a fix to use the correct approach, a call to\nnet.JoinHostPort:\n\n    addr := net.JoinHostPort(host, \"12345\")\n    ...\n    conn, err := net.Dial(\"tcp\", addr)\n\nA similar diagnostic and fix are produced for a format string of \"%s:%s\".\n",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/hostport",
			"Default": true
		},
		{
			"Name": "httpresponse",
			"Doc": "check for mistakes using HTTP responses\n\nA common mistake when using the net/http package is to defer a function\ncall to close the http.Response Body before checking the error that\ndetermines whether the response is valid:\n\n\tresp, err := http.Head(url)\n\tdefer resp.Body.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// (defer statement belongs here)\n\nThis checker helps uncover latent nil dereference bugs by reporting a\ndiagnostic for such mistakes.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/httpresponse",
			"Default": true
		},
		{
			"Name": "ifaceassert",
			"Doc": "detect impossible interface-to-interface type assertions\n\nThis checker flags type assertions v.(T) and corresponding type-switch cases\nin which the static type V of v is an interface that cannot possibly implement\nthe target interface T. This occurs when V and T contain methods with the same\nname but different signatures. Example:\n\n\tvar v interface {\n\t\tRead()\n\t}\n\t_ = v.(io.Reader)\n\nThe Read method in v has a different signature than the Read method in\nio.Reader, so this assertion cannot succeed.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/ifaceassert",
			"Default": true
		},
		{
			"Name": "infertypeargs",
			"Doc": "check for unnecessary type arguments in call expressions\n\nExplicit type arguments may be omitted from call expressions if they can be\ninferred from function arguments, or from other type arguments:\n\n\tfunc f[T any](T) {}\n\t\n\tfunc _() {\n\t\tf[string](\"foo\") // string could be inferred\n\t}\n",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/infertypeargs",
			"Default": true
		},
		{
			"Name": "inline",
			"Doc": "apply fixes based on 'go:fix inline' comment directives\n\nThe inline analyzer inlines functions and constants that are marked for inlining.\n\n## Functions\n\nGiven a function that is marked for inlining, like this one:\n\n\t//go:fix inline\n\tfunc Square(x int) int { return Pow(x, 2) }\n\nthis analyzer will recommend that calls to the function elsewhere, in the same\nor other packages, should be inlined.\n\nInlining can be used to move off of a deprecated function:\n\n\t// Deprecated: prefer Pow(x, 2).\n\t//go:fix inline\n\tfunc Square(x int) int { return Pow(x, 2) }\n\nIt can also be used to move off of an obsolete package,\nas when the import path has changed or a higher major version is available:\n\n\tpackage pkg\n\n\timport pkg2 \"pkg/v2\"\n\n\t//go:fix inline\n\tfunc F() { pkg2.F(nil) }\n\nReplacing a call pkg.F() by pkg2.F(nil) can have no effect on the program,\nso this mechanism provides a low-risk way to update large numbers of calls.\nWe recommend, where possible, expressing the old API in terms of the new one\nto enable automatic migration.\n\nThe inliner takes care to avoid behavior changes, even subtle ones,\nsuch as changes to the order in which argument expressions are\nevaluated. When it cannot safely eliminate all parameter variables,\nit may introduce a \"binding declaration\" of the form\n\n\tvar params = args\n\nto evaluate argument expressions in the correct order and bind them to\nparameter variables. Since the resulting code transformation may be\nstylistically suboptimal, such inlinings may be disabled by specifying\nthe -inline.allow_binding_decl=false flag to the analyzer driver.\n\n(In cases where it is not safe to \"reduce\" a call—that is, to replace\na call f(x) by the body of function f, suitably substituted—the\ninliner machinery is capable of replacing f by a function literal,\nfunc(){...}(). However, the inline analyzer discards all such\n\"literalizations\" unconditionally, again on grounds of style.)\n\n## Constants\n\nGiven a constant that is marked for inlining, like this one:\n\n\t//go:fix inline\n\tconst Ptr = Pointer\n\nthis analyzer will recommend that uses of Ptr should be replaced with Pointer.\n\nAs with functions, inlining can be used to replace deprecated constants and\nconstants in obsolete packages.\n\nA constant definition can be marked for inlining only if it refers to another\nnamed constant.\n\nThe \"//go:fix inline\" comment must appear before a single const declaration on its own,\nas above; before a const declaration that is part of a group, as in this case:\n\n\tconst (\n\t   C = 1\n\t   //go:fix inline\n\t   Ptr = Pointer\n\t)\n\nor before a group, applying to every constant in the group:\n\n\t//go:fix inline\n\tconst (\n\t\tPtr = Pointer\n\t    Val = Value\n\t)\n\nThe proposal https://go.dev/issue/32816 introduces the \"//go:fix inline\" directives.\n\nYou can use this command to apply inline fixes en masse:\n\n\t$ go run golang.org/x/tools/go/analysis/passes/inline/cmd/inline@latest -fix ./...",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/inline",
			"Default": true
		},
		{
			"Name": "loopclosure",
			"Doc": "check references to loop variables from within nested functions\n\nThis analyzer reports places where a function literal references the\niteration variable of an enclosing loop, and the loop calls the function\nin such a way (e.g. with go or defer) that it may outlive the loop\niteration and possibly observe the wrong value of the variable.\n\nNote: An iteration variable can only outlive a loop iteration in Go versions \u003c=1.21.\nIn Go 1.22 and later, the loop variable lifetimes changed to create a new\niteration variable per loop iteration. (See go.dev/issue/60078.)\n\nIn this example, all the deferred functions run after the loop has\ncompleted, so all observe the final value of v [\u003cgo1.22].\n\n\tfor _, v := range list {\n\t    defer func() {\n\t        use(v) // incorrect\n\t    }()\n\t}\n\nOne fix is to create a new variable for each iteration of the loop:\n\n\tfor _, v := range list {\n\t    v := v // new var per iteration\n\t    defer func() {\n\t        use(v) // ok\n\t    }()\n\t}\n\nAfter Go version 1.22, the previous two for loops are equivalent\nand both are correct.\n\nThe next example uses a go statement and has a similar problem [\u003cgo1.22].\nIn addition, it has a data race because the loop updates v\nconcurrent with the goroutines accessing it.\n\n\tfor _, v := range elem {\n\t    go func() {\n\t        use(v)  // incorrect, and a data race\n\t    }()\n\t}\n\nA fix is the same as before. The checker also reports problems\nin goroutines started by golang.org/x/sync/errgroup.Group.\nA hard-to-spot variant of this form is common in parallel tests:\n\n\tfunc Test(t *testing.T) {\n\t    for _, test := range tests {\n\t        t.Run(test.name, func(t *testing.T) {\n\t            t.Parallel()\n\t            use(test) // incorrect, and a data race\n\t        })\n\t    }\n\t}\n\nThe t.Parallel() call causes the rest of the function to execute\nconcurrent with the loop [\u003cgo1.22].\n\nThe analyzer reports references only in the last statement,\nas it is not deep enough to understand the effects of subsequent\nstatements that might render the reference benign.\n(\"Last statement\" is defined recursively in compound\nstatements such as if, switch, and select.)\n\nSee: https://golang.org/doc/go_faq.html#closures_and_goroutines",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/loopclosure",
			"Default": true
		},
		{
			"Name": "lostcancel",
			"Doc": "check cancel func returned by context.WithCancel is called\n\nThe cancellation function returned by context.WithCancel, WithTimeout,\nWithDeadline and variants such as WithCancelCause must be called,\nor the new context will remain live until its parent context is cancelled.\n(The background context is never cancelled.)",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/lostcancel",
			"Default": true
		},
		{
			"Name": "maprange",
			"Doc": "checks for unnecessary calls to maps.Keys and maps.Values in range statements\n\nConsider a loop written like this:\n\n\tfor val := range maps.Values(m) {\n\t\tfmt.Println(val)\n\t}\n\nThis should instead be written without the call to maps.Values:\n\n\tfor _, val := range m {\n\t\tfmt.Println(val)\n\t}\n\ngolang.org/x/exp/maps returns slices for Keys/Values instead of iterators,\nbut unnecessary calls should similarly be removed:\n\n\tfor _, key := range maps.Keys(m) {\n\t\tfmt.Println(key)\n\t}\n\nshould be rewritten as:\n\n\tfor key := range m {\n\t\tfmt.Println(key)\n\t}",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/maprange",
			"Default": true
		},
		{
			"Name": "mapsloop",
			"Doc": "replace explicit loops over maps with calls to maps package\n\nThe mapsloop analyzer replaces loops of the form\n\n\tfor k, v := range x { m[k] = v }\n\nwith a single call to a function from the `maps` package, added in Go 1.23.\nDepending on the context, this could be `maps.Copy`, `maps.Insert`,\n`maps.Clone`, or `maps.Collect`.\n\nThe transformation to `maps.Clone` is applied conservatively, as it\npreserves the nilness of the source map, which may be a subtle change in\nbehavior if the original code did not handle a nil map in the same way.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#mapsloop",
			"Default": true
		},
		{
			"Name": "minmax",
			"Doc": "replace if/else statements with calls to min or max\n\nThe minmax analyzer simplifies conditional assignments by suggesting the use\nof the built-in `min` and `max` functions, introduced in Go 1.21. For example,\n\n\tif a \u003c b { x = a } else { x = b }\n\nis replaced by\n\n\tx = min(a, b).\n\nThis analyzer avoids making suggestions for floating-point types,\nas the behavior of `min` and `max` with NaN values can differ from\nthe original if/else statement.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#minmax",
			"Default": true
		},
		{
			"Name": "newexpr",
			"Doc": "simplify code by using go1.26's new(expr)\n\nThis analyzer finds declarations of functions of this form:\n\n\tfunc varOf(x int) *int { return \u0026x }\n\nand suggests a fix to turn them into inlinable wrappers around\ngo1.26's built-in new(expr) function:\n\n\t//go:fix inline\n\tfunc varOf(x int) *int { return new(x) }\n\n(The directive comment causes the 'inline' analyzer to suggest\nthat calls to such functions are inlined.)\n\nIn addition, this analyzer suggests a fix for each call\nto one of the functions before it is transformed, so that\n\n\tuse(varOf(123))\n\nis replaced by:\n\n\tuse(new(123))\n\nWrapper functions such as varOf are common when working with Go\nserialization packages such as for JSON or protobuf, where pointers\nare often used to express optionality.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/modernize#newexpr",
			"Default": true
		},
		{
			"Name": "nilfunc",
			"Doc": "check for useless comparisons between functions and nil\n\nA useless comparison is one like f == nil as opposed to f() == nil.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/nilfunc",
			"Default": true
		},
		{
			"Name": "nilness",
			"Doc": "check for redundant or impossible nil comparisons\n\nThe nilness checker inspects the control-flow graph of each function in\na package and reports nil pointer dereferences, degenerate nil\npointers, and panics with nil values. A degenerate comparison is of the form\nx==nil or x!=nil where x is statically known to be nil or non-nil. These are\noften a mistake, especially in control flow related to errors. Panics with nil\nvalues are checked because they are not detectable by\n\n\tif r := recover(); r != nil {\n\nThis check reports conditions such as:\n\n\tif f == nil { // impossible condition (f is a function)\n\t}\n\nand:\n\n\tp := \u0026v\n\t...\n\tif p != nil { // tautological condition\n\t}\n\nand:\n\n\tif p == nil {\n\t\tprint(*p) // nil dereference\n\t}\n\nand:\n\n\tif p == nil {\n\t\tpanic(p)\n\t}\n\nSometimes the control flow may be quite complex, making bugs hard\nto spot. In the example below, the err.Error expression is\nguaranteed to panic because, after the first return, err must be\nnil. The intervening loop is just a distraction.\n\n\t...\n\terr := g.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpartialSuccess := false\n\tfor _, err := range errs {\n\t\tif err == nil {\n\t\t\tpartialSuccess = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif partialSuccess {\n\t\treportStatus(StatusMessage{\n\t\t\tCode:   code.ERROR,\n\t\t\tDetail: err.Error(), // \"nil dereference in dynamic method call\"\n\t\t})\n\t\treturn nil\n\t}\n\n...",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/nilness",
			"Default": true
		},
		{
			"Name": "nonewvars",
			"Doc": "suggested fixes for \"no new vars on left side of :=\"\n\nThis checker provides suggested fixes for type errors of the\ntype \"no new vars on left side of :=\". For example:\n\n\tz := 1\n\tz := 2\n\nwill turn into\n\n\tz := 1\n\tz = 2",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/nonewvars",
			"Default": true
		},
		{
			"Name": "noresultvalues",
			"Doc": "suggested fixes for unexpected return values\n\nThis checker provides suggested fixes for type errors of the\ntype \"no result values expected\" or \"too many return values\".\nFor example:\n\n\tfunc z() { return nil }\n\nwill turn into\n\n\tfunc z() { return }",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/noresultvalues",
			"Default": true
		},
		{
			"Name": "omitzero",
			"Doc": "suggest replacing omitempty with omitzero for struct fields\n\nThe omitzero analyzer identifies uses of the `omitempty` JSON struct\ntag on fields that are themselves structs. For struct-typed fields,\nthe `omitempty` tag has no effect on the behavior of json.Marshal and\njson.Unmarshal. The analyzer offers two suggestions: either remove the\ntag, or replace it with `omitzero` (added in Go 1.24), which correctly\nomits the field if the struct value is zero.\n\nHowever, some other serialization packages (notably kubebuilder, see\nhttps://book.kubebuilder.io/reference/markers.html) may have their own\ninterpretation of the `json:\",omitzero\"` tag, so removing it may affect\nprogram behavior. For this reason, the omitzero modernizer will not\nmake changes in any package that contains +kubebuilder annotations.\n\nReplacing `omitempty` with `omitzero` is a change in behavior. The\noriginal code would always encode the struct field, whereas the\nmodified code will omit it if it is a zero-value.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#omitzero",
			"Default": true
		},
		{
			"Name": "plusbuild",
			"Doc": "remove obsolete //+build comments\n\nThe plusbuild analyzer suggests a fix to remove obsolete build tags\nof the form:\n\n\t//+build linux,amd64\n\nin files that also contain a Go 1.18-style tag such as:\n\n\t//go:build linux \u0026\u0026 amd64\n\n(It does not check that the old and new tags are consistent;\nthat is the job of the 'buildtag' analyzer in the vet suite.)",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#plusbuild",
			"Default": true
		},
		{
			"Name": "printf",
			"Doc": "check consistency of Printf format strings and arguments\n\nThe check applies to calls of the formatting functions such as\n[fmt.Printf] and [fmt.Sprintf], as well as any detected wrappers of\nthose functions such as [log.Printf]. It reports a variety of\nmistakes such as syntax errors in the format string and mismatches\n(of number and type) between the verbs and their arguments.\n\nSee the documentation of the fmt package for the complete set of\nformat operators and their operand types.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/printf",
			"Default": true
		},
		{
			"Name": "rangeint",
			"Doc": "replace 3-clause for loops with for-range over integers\n\nThe rangeint analyzer suggests replacing traditional for loops such\nas\n\n\tfor i := 0; i \u003c n; i++ { ... }\n\nwith the more idiomatic Go 1.22 style:\n\n\tfor i := range n { ... }\n\nThis transformation is applied only if (a) the loop variable is not\nmodified within the loop body and (b) the loop's limit expression\nis not modified within the loop, as `for range` evaluates its\noperand only once.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#rangeint",
			"Default": true
		},
		{
			"Name": "recursiveiter",
			"Doc": "check for inefficient recursive iterators\n\nThis analyzer reports when a function that returns an iterator\n(iter.Seq or iter.Seq2) calls itself as the operand of a range\nstatement, as this is inefficient.\n\nWhen implementing an iterator (e.g. iter.Seq[T]) for a recursive\ndata type such as a tree or linked list, it is tempting to\nrecursively range over the iterator for each child element.\n\nHere's an example of a naive iterator over a binary tree:\n\n\ttype tree struct {\n\t\tvalue       int\n\t\tleft, right *tree\n\t}\n\n\tfunc (t *tree) All() iter.Seq[int] {\n\t\treturn func(yield func(int) bool) {\n\t\t\tif t != nil {\n\t\t\t\tfor elem := range t.left.All() { // \"inefficient recursive iterator\"\n\t\t\t\t\tif !yield(elem) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !yield(t.value) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor elem := range t.right.All() { // \"inefficient recursive iterator\"\n\t\t\t\t\tif !yield(elem) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nThough it correctly enumerates the elements of the tree, it hides a\nsignificant performance problem--two, in fact. Consider a balanced\ntree of N nodes. Iterating the root node will cause All to be\ncalled once on every node of the tree. This results in a chain of\nnested active range-over-func statements when yield(t.value) is\ncalled on a leaf node.\n\nThe first performance problem is that each range-over-func\nstatement must typically heap-allocate a variable, so iteration of\nthe tree allocates as many variables as there are elements in the\ntree, for a total of O(N) allocations, all unnecessary.\n\nThe second problem is that each call to yield for a leaf of the\ntree causes each of the enclosing range loops to receive a value,\nwhich they then immediately pass on to their respective yield\nfunction. This results in a chain of log(N) dynamic yield calls per\nelement, a total of O(N*log N) dynamic calls overall, when only\nO(N) are necessary.\n\nA better implementation strategy for recursive iterators is to\nfirst define the \"every\" operator for your recursive data type,\nwhere every(f) reports whether an arbitrary predicate f(x) is true\nfor every element x in the data type. For our tree, the every\nfunction would be:\n\n\tfunc (t *tree) every(f func(int) bool) bool {\n\t\treturn t == nil ||\n\t\t\tt.left.every(f) \u0026\u0026 f(t.value) \u0026\u0026 t.right.every(f)\n\t}\n\nFor example, this use of the every operator prints whether every\nelement in the tree is an even number:\n\n\teven := func(x int) bool { return x\u00261 == 0 }\n\tprintln(t.every(even))\n\nThen the iterator can be simply expressed as a trivial wrapper\naround the every operator:\n\n\tfunc (t *tree) All() iter.Seq[int] {\n\t\treturn func(yield func(int) bool) {\n\t\t\t_ = t.every(yield)\n\t\t}\n\t}\n\nIn effect, tree.All computes whether yield returns true for each\nelement, short-circuiting if it ever returns false, then discards\nthe final boolean result.\n\nThis has much better performance characteristics: it makes one\ndynamic call per element of the tree, and it doesn't heap-allocate\nanything. It is also clearer.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/recursiveiter",
			"Default": true
		},
		{
			"Name": "reflecttypefor",
			"Doc": "replace reflect.TypeOf(x) with TypeFor[T]()\n\nThis analyzer suggests fixes to replace uses of reflect.TypeOf(x) with\nreflect.TypeFor, introduced in go1.22, when the desired runtime type\nis known at compile time, for example:\n\n\treflect.TypeOf(uint32(0))        -\u003e reflect.TypeFor[uint32]()\n\treflect.TypeOf((*ast.File)(nil)) -\u003e reflect.TypeFor[*ast.File]()\n\nIt also offers a fix to simplify the construction below, which uses\nreflect.TypeOf to return the runtime type for an interface type,\n\n\treflect.TypeOf((*io.Reader)(nil)).Elem()\n\nto:\n\n\treflect.TypeFor[io.Reader]()\n\nNo fix is offered in cases when the runtime type is dynamic, such as:\n\n\tvar r io.Reader = ...\n\treflect.TypeOf(r)\n\nor when the operand has potential side effects.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#reflecttypefor",
			"Default": true
		},
		{
			"Name": "shadow",
			"Doc": "check for possible unintended shadowing of variables\n\nThis analyzer check for shadowed variables.\nA shadowed variable is a variable declared in an inner scope\nwith the same name and type as a variable in an outer scope,\nand where the outer variable is mentioned after the inner one\nis declared.\n\n(This definition can be refined; the module generates too many\nfalse positives and is not yet enabled by default.)\n\nFor example:\n\n\tfunc BadRead(f *os.File, buf []byte) error {\n\t\tvar err error\n\t\tfor {\n\t\t\tn, err := f.Read(buf) // shadows the function variable 'err'\n\t\t\tif err != nil {\n\t\t\t\tbreak // causes return of wrong value\n\t\t\t}\n\t\t\tfoo(buf)\n\t\t}\n\t\treturn err\n\t}",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/shadow",
			"Default": false
		},
		{
			"Name": "shift",
			"Doc": "check for shifts that equal or exceed the width of the integer",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/shift",
			"Default": true
		},
		{
			"Name": "sigchanyzer",
			"Doc": "check for unbuffered channel of os.Signal\n\nThis checker reports call expression of the form\n\n\tsignal.Notify(c \u003c-chan os.Signal, sig ...os.Signal),\n\nwhere c is an unbuffered channel, which can be at risk of missing the signal.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/sigchanyzer",
			"Default": true
		},
		{
			"Name": "simplifycompositelit",
			"Doc": "check for composite literal simplifications\n\nAn array, slice, or map composite literal of the form:\n\n\t[]T{T{}, T{}}\n\nwill be simplified to:\n\n\t[]T{{}, {}}\n\nThis is one of the simplifications that \"gofmt -s\" applies.\n\nThis analyzer ignores generated code.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/simplifycompositelit",
			"Default": true
		},
		{
			"Name": "simplifyrange",
			"Doc": "check for range statement simplifications\n\nA range of the form:\n\n\tfor x, _ = range v {...}\n\nwill be simplified to:\n\n\tfor x = range v {...}\n\nA range of the form:\n\n\tfor _ = range v {...}\n\nwill be simplified to:\n\n\tfor range v {...}\n\nThis is one of the simplifications that \"gofmt -s\" applies.\n\nThis analyzer ignores generated code.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/simplifyrange",
			"Default": true
		},
		{
			"Name": "simplifyslice",
			"Doc": "check for slice simplifications\n\nA slice expression of the form:\n\n\ts[a:len(s)]\n\nwill be simplified to:\n\n\ts[a:]\n\nThis is one of the simplifications that \"gofmt -s\" applies.\n\nThis analyzer ignores generated code.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/simplifyslice",
			"Default": true
		},
		{
			"Name": "slicescontains",
			"Doc": "replace loops with slices.Contains or slices.ContainsFunc\n\nThe slicescontains analyzer simplifies loops that check for the existence of\nan element in a slice. It replaces them with calls to `slices.Contains` or\n`slices.ContainsFunc`, which were added in Go 1.21.\n\nIf the expression for the target element has side effects, this\ntransformation will cause those effects to occur only once, not\nonce per tested slice element.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#slicescontains",
			"Default": true
		},
		{
			"Name": "slicesdelete",
			"Doc": "replace append-based slice deletion with slices.Delete\n\nThe slicesdelete analyzer suggests replacing the idiom\n\n\ts = append(s[:i], s[j:]...)\n\nwith the more explicit\n\n\ts = slices.Delete(s, i, j)\n\nintroduced in Go 1.21.\n\nThis analyzer is disabled by default. The `slices.Delete` function\nzeros the elements between the new length and the old length of the\nslice to prevent memory leaks, which is a subtle difference in\nbehavior compared to the append-based idiom; see https://go.dev/issue/73686.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#slicesdelete",
			"Default": false
		},
		{
			"Name": "slicessort",
			"Doc": "replace sort.Slice with slices.Sort for basic types\n\nThe slicessort analyzer simplifies sorting slices of basic ordered\ntypes. It replaces\n\n\tsort.Slice(s, func(i, j int) bool { return s[i] \u003c s[j] })\n\nwith the simpler `slices.Sort(s)`, which was added in Go 1.21.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#slicessort",
			"Default": true
		},
		{
			"Name": "slog",
			"Doc": "check for invalid structured logging calls\n\nThe slog checker looks for calls to functions from the log/slog\npackage that take alternating key-value pairs. It reports calls\nwhere an argument in a key position is neither a string nor a\nslog.Attr, and where a final key is missing its value.\nFor example,it would report\n\n\tslog.Warn(\"message\", 11, \"k\") // slog.Warn arg \"11\" should be a string or a slog.Attr\n\nand\n\n\tslog.Info(\"message\", \"k1\", v1, \"k2\") // call to slog.Info missing a final value",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/slog",
			"Default": true
		},
		{
			"Name": "sortslice",
			"Doc": "check the argument type of sort.Slice\n\nsort.Slice requires an argument of a slice type. Check that\nthe interface{} value passed to sort.Slice is actually a slice.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/sortslice",
			"Default": true
		},
		{
			"Name": "stditerators",
			"Doc": "use iterators instead of Len/At-style APIs\n\nThis analyzer suggests a fix to replace each loop of the form:\n\n\tfor i := 0; i \u003c x.Len(); i++ {\n\t\tuse(x.At(i))\n\t}\n\nor its \"for elem := range x.Len()\" equivalent by a range loop over an\niterator offered by the same data type:\n\n\tfor elem := range x.All() {\n\t\tuse(x.At(i)\n\t}\n\nwhere x is one of various well-known types in the standard library.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#stditerators",
			"Default": true
		},
		{
			"Name": "stdmethods",
			"Doc": "check signature of methods of well-known interfaces\n\nSometimes a type may be intended to satisfy an interface but may fail to\ndo so because of a mistake in its method signature.\nFor example, the result of this WriteTo method should be (int64, error),\nnot error, to satisfy io.WriterTo:\n\n\ttype myWriterTo struct{...}\n\tfunc (myWriterTo) WriteTo(w io.Writer) error { ... }\n\nThis check ensures that each method whose name matches one of several\nwell-known interface methods from the standard library has the correct\nsignature for that interface.\n\nChecked method names include:\n\n\tFormat GobEncode GobDecode MarshalJSON MarshalXML\n\tPeek ReadByte ReadFrom ReadRune Scan Seek\n\tUnmarshalJSON UnreadByte UnreadRune WriteByte\n\tWriteTo",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/stdmethods",
			"Default": true
		},
		{
			"Name": "stdversion",
			"Doc": "report uses of too-new standard library symbols\n\nThe stdversion analyzer reports references to symbols in the standard\nlibrary that were introduced by a Go release higher than the one in\nforce in the referring file. (Recall that the file's Go version is\ndefined by the 'go' directive its module's go.mod file, or by a\n\"//go:build go1.X\" build tag at the top of the file.)\n\nThe analyzer does not report a diagnostic for a reference to a \"too\nnew\" field or method of a type that is itself \"too new\", as this may\nhave false positives, for example if fields or methods are accessed\nthrough a type alias that is guarded by a Go version constraint.\n",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/stdversion",
			"Default": true
		},
		{
			"Name": "stringintconv",
			"Doc": "check for string(int) conversions\n\nThis checker flags conversions of the form string(x) where x is an integer\n(but not byte or rune) type. Such conversions are discouraged because they\nreturn the UTF-8 representation of the Unicode code point x, and not a decimal\nstring representation of x as one might expect. Furthermore, if x denotes an\ninvalid code point, the conversion cannot be statically rejected.\n\nFor conversions that intend on using the code point, consider replacing them\nwith string(rune(x)). Otherwise, strconv.Itoa and its equivalents return the\nstring representation of the value in the desired base.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/stringintconv",
			"Default": true
		},
		{
			"Name": "stringsbuilder",
			"Doc": "replace += with strings.Builder\n\nThis analyzer replaces repeated string += string concatenation\noperations with calls to Go 1.10's strings.Builder.\n\nFor example:\n\n\tvar s = \"[\"\n\tfor x := range seq {\n\t\ts += x\n\t\ts += \".\"\n\t}\n\ts += \"]\"\n\tuse(s)\n\nis replaced by:\n\n\tvar s strings.Builder\n\ts.WriteString(\"[\")\n\tfor x := range seq {\n\t\ts.WriteString(x)\n\t\ts.WriteString(\".\")\n\t}\n\ts.WriteString(\"]\")\n\tuse(s.String())\n\nThis avoids quadratic memory allocation and improves performance.\n\nThe analyzer requires that all references to s except the final one\nare += operations. To avoid warning about trivial cases, at least one\nmust appear within a loop. The variable s must be a local\nvariable, not a global or parameter.\n\nThe sole use of the finished string must be the last reference to the\nvariable s. (It may appear within an intervening loop or function literal,\nsince even s.String() is called repeatedly, it does not allocate memory.)",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#stringbuilder",
			"Default": true
		},
		{
			"Name": "stringscut",
			"Doc": "replace strings.Index etc. with strings.Cut\n\nThis analyzer replaces certain patterns of use of [strings.Index] and string slicing by [strings.Cut], added in go1.18.\n\nFor example:\n\n\tidx := strings.Index(s, substr)\n\tif idx \u003e= 0 {\n\t    return s[:idx]\n\t}\n\nis replaced by:\n\n\tbefore, _, ok := strings.Cut(s, substr)\n\tif ok {\n\t    return before\n\t}\n\nAnd:\n\n\tidx := strings.Index(s, substr)\n\tif idx \u003e= 0 {\n\t    return\n\t}\n\nis replaced by:\n\n\tfound := strings.Contains(s, substr)\n\tif found {\n\t    return\n\t}\n\nIt also handles variants using [strings.IndexByte] instead of Index, or the bytes package instead of strings.\n\nFixes are offered only in cases in which there are no potential modifications of the idx, s, or substr expressions between their definition and use.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/modernize#stringscut",
			"Default": true
		},
		{
			"Name": "stringscutprefix",
			"Doc": "replace HasPrefix/TrimPrefix with CutPrefix\n\nThe stringscutprefix analyzer simplifies a common pattern where code first\nchecks for a prefix with `strings.HasPrefix` and then removes it with\n`strings.TrimPrefix`. It replaces this two-step process with a single call\nto `strings.CutPrefix`, introduced in Go 1.20. The analyzer also handles\nthe equivalent functions in the `bytes` package.\n\nFor example, this input:\n\n\tif strings.HasPrefix(s, prefix) {\n\t    use(strings.TrimPrefix(s, prefix))\n\t}\n\nis fixed to:\n\n\tif after, ok := strings.CutPrefix(s, prefix); ok {\n\t    use(after)\n\t}\n\nThe analyzer also offers fixes to use CutSuffix in a similar way.\nThis input:\n\n\tif strings.HasSuffix(s, suffix) {\n\t    use(strings.TrimSuffix(s, suffix))\n\t}\n\nis fixed to:\n\n\tif before, ok := strings.CutSuffix(s, suffix); ok {\n\t    use(before)\n\t}",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#stringscutprefix",
			"Default": true
		},
		{
			"Name": "stringsseq",
			"Doc": "replace ranging over Split/Fields with SplitSeq/FieldsSeq\n\nThe stringsseq analyzer improves the efficiency of iterating over substrings.\nIt replaces\n\n\tfor range strings.Split(...)\n\nwith the more efficient\n\n\tfor range strings.SplitSeq(...)\n\nwhich was added in Go 1.24 and avoids allocating a slice for the\nsubstrings. The analyzer also handles strings.Fields and the\nequivalent functions in the bytes package.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#stringsseq",
			"Default": true
		},
		{
			"Name": "structtag",
			"Doc": "check that struct field tags conform to reflect.StructTag.Get\n\nAlso report certain struct tags (json, xml) used with unexported fields.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/structtag",
			"Default": true
		},
		{
			"Name": "testingcontext",
			"Doc": "replace context.WithCancel with t.Context in tests\n\nThe testingcontext analyzer simplifies context management in tests. It\nreplaces the manual creation of a cancellable context,\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\nwith a single call to t.Context(), which was added in Go 1.24.\n\nThis change is only suggested if the `cancel` function is not used\nfor any other purpose.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#testingcontext",
			"Default": true
		},
		{
			"Name": "testinggoroutine",
			"Doc": "report calls to (*testing.T).Fatal from goroutines started by a test\n\nFunctions that abruptly terminate a test, such as the Fatal, Fatalf, FailNow, and\nSkip{,f,Now} methods of *testing.T, must be called from the test goroutine itself.\nThis checker detects calls to these functions that occur within a goroutine\nstarted by the test. For example:\n\n\tfunc TestFoo(t *testing.T) {\n\t    go func() {\n\t        t.Fatal(\"oops\") // error: (*T).Fatal called from non-test goroutine\n\t    }()\n\t}",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/testinggoroutine",
			"Default": true
		},
		{
			"Name": "tests",
			"Doc": "check for common mistaken usages of tests and examples\n\nThe tests checker walks Test, Benchmark, Fuzzing and Example functions checking\nmalformed names, wrong signatures and examples documenting non-existent\nidentifiers.\n\nPlease see the documentation for package testing in golang.org/pkg/testing\nfor the conventions that are enforced for Tests, Benchmarks, and Examples.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/tests",
			"Default": true
		},
		{
			"Name": "timeformat",
			"Doc": "check for calls of (time.Time).Format or time.Parse with 2006-02-01\n\nThe timeformat checker looks for time formats with the 2006-02-01 (yyyy-dd-mm)\nformat. Internationally, \"yyyy-dd-mm\" does not occur in common calendar date\nstandards, and so it is more likely that 2006-01-02 (yyyy-mm-dd) was intended.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/timeformat",
			"Default": true
		},
		{
			"Name": "unmarshal",
			"Doc": "report passing non-pointer or non-interface values to unmarshal\n\nThe unmarshal analysis reports calls to functions such as json.Unmarshal\nin which the argument type is not a pointer or an interface.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/unmarshal",
			"Default": true
		},
		{
			"Name": "unreachable",
			"Doc": "check for unreachable code\n\nThe unreachable analyzer finds statements that execution can never reach\nbecause they are preceded by a return statement, a call to panic, an\ninfinite loop, or similar constructs.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/unreachable",
			"Default": true
		},
		{
			"Name": "unsafefuncs",
			"Doc": "replace unsafe pointer arithmetic with function calls\n\nThe unsafefuncs analyzer simplifies pointer arithmetic expressions by\nreplacing them with calls to helper functions such as unsafe.Add,\nadded in Go 1.17.\n\nExample:\n\n\tunsafe.Pointer(uintptr(ptr) + uintptr(n))\n\nwhere ptr is an unsafe.Pointer, is replaced by:\n\n\tunsafe.Add(ptr, n)",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#unsafefuncs",
			"Default": true
		},
		{
			"Name": "unsafeptr",
			"Doc": "check for invalid conversions of uintptr to unsafe.Pointer\n\nThe unsafeptr analyzer reports likely incorrect uses of unsafe.Pointer\nto convert integers to pointers. A conversion from uintptr to\nunsafe.Pointer is invalid if it implies that there is a uintptr-typed\nword in memory that holds a pointer value, because that word will be\ninvisible to stack copying and to the garbage collector.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/unsafeptr",
			"Default": true
		},
		{
			"Name": "unusedfunc",
			"Doc": "check for unused functions, methods, etc\n\nThe unusedfunc analyzer reports functions and methods that are\nnever referenced outside of their own declaration.\n\nA function is considered unused if it is unexported and not\nreferenced (except within its own declaration).\n\nA method is considered unused if it is unexported, not referenced\n(except within its own declaration), and its name does not match\nthat of any method of an interface type declared within the same\npackage.\n\nThe tool may report false positives in some situations, for\nexample:\n\n  - for a declaration of an unexported function that is referenced\n    from another package using the go:linkname mechanism, if the\n    declaration's doc comment does not also have a go:linkname\n    comment.\n\n    (Such code is in any case strongly discouraged: linkname\n    annotations, if they must be used at all, should be used on both\n    the declaration and the alias.)\n\n  - for compiler intrinsics in the \"runtime\" package that, though\n    never referenced, are known to the compiler and are called\n    indirectly by compiled object code.\n\n  - for functions called only from assembly.\n\n  - for functions called only from files whose build tags are not\n    selected in the current build configuration.\n\nSince these situations are relatively common in the low-level parts\nof the runtime, this analyzer ignores the standard library.\nSee https://go.dev/issue/71686 and https://go.dev/issue/74130 for\nfurther discussion of these limitations.\n\nThe unusedfunc algorithm is not as precise as the\ngolang.org/x/tools/cmd/deadcode tool, but it has the advantage that\nit runs within the modular analysis framework, enabling near\nreal-time feedback within gopls.\n\nThe unusedfunc analyzer also reports unused types, vars, and\nconstants. Enums--constants defined with iota--are ignored since\neven the unused values must remain present to preserve the logical\nordering.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/unusedfunc",
			"Default": true
		},
		{
			"Name": "unusedparams",
			"Doc": "check for unused parameters of functions\n\nThe unusedparams analyzer checks functions to see if there are\nany parameters that are not being used.\n\nTo ensure soundness, it ignores:\n  - \"address-taken\" functions, that is, functions that are used as\n    a value rather than being called directly; their signatures may\n    be required to conform to a func type.\n  - exported functions or methods, since they may be address-taken\n    in another package.\n  - unexported methods whose name matches an interface method\n    declared in the same package, since the method's signature\n    may be required to conform to the interface type.\n  - functions with empty bodies, or containing just a call to panic.\n  - parameters that are unnamed, or named \"_\", the blank identifier.\n\nThe analyzer suggests a fix of replacing the parameter name by \"_\",\nbut in such cases a deeper fix can be obtained by invoking the\n\"Refactor: remove unused parameter\" code action, which will\neliminate the parameter entirely, along with all corresponding\narguments at call sites, while taking care to preserve any side\neffects in the argument expressions; see\nhttps://github.com/golang/tools/releases/tag/gopls%2Fv0.14.\n\nThis analyzer ignores generated code.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/unusedparams",
			"Default": true
		},
		{
			"Name": "unusedresult",
			"Doc": "check for unused results of calls to some functions\n\nSome functions like fmt.Errorf return a result and have no side\neffects, so it is always a mistake to discard the result. Other\nfunctions may return an error that must not be ignored, or a cleanup\noperation that must be called. This analyzer reports calls to\nfunctions like these when the result of the call is ignored.\n\nThe set of functions may be controlled using flags.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/unusedresult",
			"Default": true
		},
		{
			"Name": "unusedvariable",
			"Doc": "check for unused variables and suggest fixes",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/unusedvariable",
			"Default": true
		},
		{
			"Name": "unusedwrite",
			"Doc": "checks for unused writes\n\nThe analyzer reports instances of writes to struct fields and\narrays that are never read. Specifically, when a struct object\nor an array is copied, its elements are copied implicitly by\nthe compiler, and any element write to this copy does nothing\nwith the original object.\n\nFor example:\n\n\ttype T struct { x int }\n\n\tfunc f(input []T) {\n\t\tfor i, v := range input {  // v is a copy\n\t\t\tv.x = i  // unused write to field x\n\t\t}\n\t}\n\nAnother example is about non-pointer receiver:\n\n\ttype T struct { x int }\n\n\tfunc (t T) f() {  // t is a copy\n\t\tt.x = i  // unused write to field x\n\t}",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/unusedwrite",
			"Default": true
		},
		{
			"Name": "waitgroup",
			"Doc": "check for misuses of sync.WaitGroup\n\nThis analyzer detects mistaken calls to the (*sync.WaitGroup).Add\nmethod from inside a new goroutine, causing Add to race with Wait:\n\n\t// WRONG\n\tvar wg sync.WaitGroup\n\tgo func() {\n\t        wg.Add(1) // \"WaitGroup.Add called from inside new goroutine\"\n\t        defer wg.Done()\n\t        ...\n\t}()\n\twg.Wait() // (may return prematurely before new goroutine starts)\n\nThe correct code calls Add before starting the goroutine:\n\n\t// RIGHT\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t...\n\t}()\n\twg.Wait()",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/waitgroup",
			"Default": true
		},
		{
			"Name": "waitgroup",
			"Doc": "replace wg.Add(1)/go/wg.Done() with wg.Go\n\nThe waitgroup analyzer simplifies goroutine management with `sync.WaitGroup`.\nIt replaces the common pattern\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t...\n\t}()\n\nwith a single call to\n\n\twg.Go(func(){ ... })\n\nwhich was added in Go 1.25.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#waitgroup",
			"Default": true
		},
		{
			"Name": "yield",
			"Doc": "report calls to yield where the result is ignored\n\nAfter a yield function returns false, the caller should not call\nthe yield function again; generally the iterator should return\npromptly.\n\nThis example fails to check the result of the call to yield,\ncausing this analyzer to report a diagnostic:\n\n\tyield(1) // yield may be called again (on L2) after returning false\n\tyield(2)\n\nThe corrected code is either this:\n\n\tif yield(1) { yield(2) }\n\nor simply:\n\n\t_ = yield(1) \u0026\u0026 yield(2)\n\nIt is not always a mistake to ignore the result of yield.\nFor example, this is a valid single-element iterator:\n\n\tyield(1) // ok to ignore result\n\treturn\n\nIt is only a mistake when the yield call that returned false may be\nfollowed by another call.",
			"URL": "https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/yield",
			"Default": true
		}
	],
	"Hints": [
		{
			"Name": "assignVariableTypes",
			"Doc": "`\"assignVariableTypes\"` controls inlay hints for variable types in assign statements:\n```go\n\ti/* int*/, j/* int*/ := 0, len(r)-1\n```\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "compositeLiteralFields",
			"Doc": "`\"compositeLiteralFields\"` inlay hints for composite literal field names:\n```go\n\t{/*in: */\"Hello, world\", /*want: */\"dlrow ,olleH\"}\n```\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "compositeLiteralTypes",
			"Doc": "`\"compositeLiteralTypes\"` controls inlay hints for composite literal types:\n```go\n\tfor _, c := range []struct {\n\t\tin, want string\n\t}{\n\t\t/*struct{ in string; want string }*/{\"Hello, world\", \"dlrow ,olleH\"},\n\t}\n```\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "constantValues",
			"Doc": "`\"constantValues\"` controls inlay hints for constant values:\n```go\n\tconst (\n\t\tKindNone   Kind = iota/* = 0*/\n\t\tKindPrint/*  = 1*/\n\t\tKindPrintf/* = 2*/\n\t\tKindErrorf/* = 3*/\n\t)\n```\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "functionTypeParameters",
			"Doc": "`\"functionTypeParameters\"` inlay hints for implicit type parameters on generic functions:\n```go\n\tmyFoo/*[int, string]*/(1, \"hello\")\n```\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "ignoredError",
			"Doc": "`\"ignoredError\"` inlay hints for implicitly discarded errors:\n```go\n\tf.Close() // ignore error\n```\nThis check inserts an `// ignore error` hint following any\nstatement that is a function call whose error result is\nimplicitly ignored.\n\nTo suppress the hint, write an actual comment containing\n\"ignore error\" following the call statement, or explictly\nassign the result to a blank variable. A handful of common\nfunctions such as `fmt.Println` are excluded from the\ncheck.\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "parameterNames",
			"Doc": "`\"parameterNames\"` controls inlay hints for parameter names:\n```go\n\tparseInt(/* str: */ \"123\", /* radix: */ 8)\n```\n",
			"Default": false,
			"Status": ""
		},
		{
			"Name": "rangeVariableTypes",
			"Doc": "`\"rangeVariableTypes\"` controls inlay hints for variable types in range statements:\n```go\n\tfor k/* int*/, v/* string*/ := range []string{} {\n\t\tfmt.Println(k, v)\n\t}\n```\n",
			"Default": false,
			"Status": ""
		}
	]
}