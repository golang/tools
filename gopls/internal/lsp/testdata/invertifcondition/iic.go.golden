-- suggestedfix_iic_9_2 --
package invertifcondition

import (
	"fmt"
	"os"
)

func F() {
	if len(os.Args) <= 2 { //@suggestedfix("i", "refactor.rewrite", "")
		fmt.Println("B")
	} else {
		fmt.Println("A")
	}

	if _, err := fmt.Println("x"); err == nil { //@suggestedfix("if", "refactor.rewrite", "")
		fmt.Println("B")
	} else {
		fmt.Println("A")
	}

	if n, err := fmt.Println("x"); err == nil || n <= 0 { //@suggestedfix("f", "refactor.rewrite", "")
		fmt.Println("B")
	} else {
		fmt.Println("A")
	}

	if n, err := fmt.Println("x"); err == nil && n <= 0 { //@suggestedfix(re"if n, err := fmt.Println..x..; err != nil .. n > 0", "refactor.rewrite", "")
		fmt.Println("B")
	} else {
		fmt.Println("A")
	}

	// No inversion expected when there's not else clause
	if len(os.Args) > 2 {
		fmt.Println("A")
	}

	// No inversion expected for else-if, that would become unreadable
	if len(os.Args) > 2 {
		fmt.Println("A")
	} else if os.Args[0] != "X" { //@suggestedfix(re"if os.Args.0. == .X.", "refactor.rewrite", "")
		fmt.Println("C")
	} else {
		fmt.Println("B")
	}

	b := true
	if !b { //@suggestedfix("if b", "refactor.rewrite", "")
		fmt.Println("B")
	} else {
		fmt.Println("A")
	}

	if !os.IsPathSeparator('X') { //@suggestedfix("if os.IsPathSeparator('X')", "refactor.rewrite", "")
		fmt.Println("B")
	} else {
		fmt.Println("A")
	}
}
